{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#reproducible-spatial-transcriptomics-pipeline-with-rse-best-practices","title":"Reproducible Spatial Transcriptomics Pipeline with RSE Best Practices","text":"<p>This is a brief abstract of my exemplar, which includes a representative image. </p> <p>This exemplar was developed at Imperial College London by Sara Patti in collaboration with Adrian D'Alessandro from Research Software Engineering and Jesus Urtasun from Research Computing &amp; Data Science at the Early Career Researcher Institute.</p>"},{"location":"#learning-outcomes","title":"Learning Outcomes \ud83c\udf93","text":"<p>After completing this exemplar, students will:</p> <ul> <li>Analyze spatial transcriptomic data (Xenium)</li> <li>Develop a reporducible pipeline</li> <li>Implement RSE best practices (e.g testing, continuous integration)</li> </ul>"},{"location":"#target-audience","title":"Target Audience \ud83c\udfaf","text":"<p>1) Biologists interested in developing bioinformatic pipelines 2) RSE interested in analyzing spatial transcriptomics data</p>"},{"location":"#prerequisites","title":"Prerequisites \u2705","text":""},{"location":"#academic","title":"Academic \ud83d\udcda","text":"<ul> <li>Required skills/knowledge (e.g. programming languages, libraries, theory, courses)</li> </ul>"},{"location":"#system","title":"System \ud83d\udcbb","text":"<ul> <li>System requirements (e.g. Python 3.11+, Anaconda, 50 GB disk space, etc.)</li> <li>Hardware or HPC requirements (if any)</li> </ul>"},{"location":"#getting-started","title":"Getting Started \ud83d\ude80","text":"<p>e.g. Step-by-step guide:</p> <ol> <li>Start by downloading the Xenium Lung FFPE data</li> <li> <p>Data can be downloaded from the 10x Genomics website, or directly from the command line.</p> <ul> <li>If downloading from the website, download the <code>Xenium_V1_Human_Lung_Cancer_Addon_FFPE_outs.zip</code> file.</li> <li> <p>If downloading from the command line, use the following command:</p> <pre><code>curl -O https://cf.10xgenomics.com/samples/xenium/2.0.0/Xenium_V1_Human_Lung_Cancer_Addon_FFPE/Xenium_V1_Human_Lung_Cancer_Addon_FFPE_outs.zip\n</code></pre> </li> </ul> </li> <li> <p>Unzip the downloaded file.</p> <ul> <li>If you downloaded the file from the website, unzip it using your preferred method.</li> <li> <p>If you downloaded the file from the command line, use the following command:</p> <pre><code>unzip Xenium_V1_Human_Lung_Cancer_Addon_FFPE_outs.zip\n</code></pre> </li> </ul> </li> <li> <p>Visit the sections of this notebook in some particular order.</p> </li> <li>Attempt exercises <code>1a</code>, <code>1b</code>, etc.</li> <li>Progress to advanced materials in the Github repository linked here.</li> <li>Compare with solutions available in the <code>solutions</code> folder.</li> </ol> <p>Briefly describe how this project fits in your discipline, why you chose to work on it, and what other disciplines may find it useful.</p>"},{"location":"#software-tools","title":"Software Tools \ud83d\udee0\ufe0f","text":"<p>Python, squidpy, MuSpAn</p>"},{"location":"#project-structure","title":"Project Structure \ud83d\uddc2\ufe0f","text":"<p>Overview of code organisation and structure.</p> <pre><code>.\n\u251c\u2500\u2500 notebooks\n\u2502 \u251c\u2500\u2500 ex1.ipynb\n\u251c\u2500\u2500 src\n\u2502 \u251c\u2500\u2500 file1.py\n\u2502 \u251c\u2500\u2500 file2.cpp\n\u2502 \u251c\u2500\u2500 ...\n\u2502 \u2514\u2500\u2500 data\n\u251c\u2500\u2500 docs\n\u2514\u2500\u2500 test\n</code></pre> <p>Code is organised into logical components:</p> <ul> <li><code>notebooks</code> for tutorials and exercises</li> <li><code>src</code> for core code, potentially divided into further modules</li> <li><code>data</code> within <code>src</code> for datasets</li> <li><code>docs</code> for documentation</li> <li><code>test</code> for testing scripts</li> </ul>"},{"location":"#roadmap","title":"Roadmap \ud83d\uddfa\ufe0f","text":""},{"location":"#preprocessing-quality-control","title":"Preprocessing &amp; Quality Control","text":"<p>Goal: Ensure clean, usable spatial gene expression data.</p> <ul> <li>Run xenium output through Space Ranger or Xenium tools</li> <li>Filter low-quality spots/cells</li> <li>Normalize gene counts</li> </ul>"},{"location":"#dimensionality-reduction-clustering","title":"Dimensionality Reduction &amp; Clustering","text":"<p>Goal: Identify patterns and groups of similar gene expression profiles.</p> <ul> <li>PCA + UMAP/t-SNE</li> <li>Cluster by gene expression</li> <li>Identify cell types with marker genes</li> </ul>"},{"location":"#spatial-mapping-visualization","title":"Spatial Mapping &amp; Visualization","text":"<p>Goal: Map gene expression and clusters back to their spatial context.</p> <ul> <li>Overlay expression and clusters on tissue image</li> <li>Plot spatially enriched genes</li> <li>Map cell types or states in space</li> </ul>"},{"location":"#differential-expression-functional-analysis","title":"Differential Expression &amp; Functional Analysis","text":"<p>Goal: Discover meaningful biology.</p> <ul> <li>Spatially variable genes (SVGs)</li> <li>DE between regions or conditions</li> <li>Pathway or GO enrichment</li> </ul>"},{"location":"#data","title":"Data \ud83d\udcca","text":"<p>List datasets used with:</p> <ul> <li>Licensing info</li> <li>Where they are included (in the repo or external links)</li> </ul>"},{"location":"#best-practice-notes","title":"Best Practice Notes \ud83d\udcdd","text":"<ul> <li>Code testing and/or test examples</li> <li>Use of continuous integration (if any)</li> <li>Any other software development best practices</li> </ul>"},{"location":"#estimated-time","title":"Estimated Time \u23f3","text":"Task Time Reading 3 hours Practising 3 hours"},{"location":"#additional-resources","title":"Additional Resources \ud83d\udd17","text":"<ul> <li>Relevant sources, websites, images, AOB.</li> </ul>"},{"location":"#licence","title":"Licence \ud83d\udcc4","text":"<p>This project is licensed under the BSD-3-Clause license.</p>"},{"location":"content/","title":"Some more content","text":"<p>Here is some other interesting content in a regular Markdown file.</p> <p></p>"},{"location":"installation/","title":"Installation Guide","text":"<p>To install the most basic version of this project, create a python virtual environment and run:</p> <pre><code>pip install git+https://github.com/ImperialCollegeLondon/ReCoDe-spatial-transcriptomics.git\n</code></pre> <p>However, there are some analysis modules that use the tool <code>MuSpAn</code>, which requires a license to install. If you want to use those modules, you will need to request a license. Do this by following the link in the MuSpAn installation instructions. Once you have your username and password, run the following command and enter them when prompted.</p> <pre><code>pip install 'recode_st[muspan] @ git+https://github.com/ImperialCollegeLondon/ReCoDe-spatial-transcriptomics.git'\n</code></pre>"},{"location":"installation/#development-installation","title":"Development installation","text":"<p>To install the development version of the software, clone this repo and run</p> <pre><code>pip install -e \".[dev,muspan]\"\n</code></pre>"},{"location":"sample/","title":"Creating spatial networks","text":"In\u00a0[1]: Copied! <pre>import os\nimport sys\n\nsys.path.append(os.path.abspath(\"../src\"))\n</pre> import os import sys  sys.path.append(os.path.abspath(\"../src\")) In\u00a0[2]: Copied! <pre># Import packages\nimport logging\nimport os\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nimport muspan as ms\nimport numpy as np\nimport scanpy as sc\nimport spatialdata as sd\nimport squidpy as sq\nimport seaborn as sns\n</pre> # Import packages import logging import os from pathlib import Path  import matplotlib.pyplot as plt import muspan as ms import numpy as np import scanpy as sc import spatialdata as sd import squidpy as sq import seaborn as sns In\u00a0[3]: Copied! <pre># Set variables\nmodule_name = \"5_muspan\"  # name of the module\n</pre> # Set variables module_name = \"5_muspan\"  # name of the module  In\u00a0[4]: Copied! <pre># Set directories\nbase_dir = \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics\"\ninput_path = base_dir\noutput_path = Path(base_dir) / \"analysis\"\nlogging_path = Path(output_path) / \"logging\"\nzarr_path = Path(input_path) / \"data/xenium.zarr\"\narea_path = Path(input_path) / \"data/section_one_cells.csv\"\n\n# Confirm directories exist\nif not Path(input_path).exists():\n    raise FileNotFoundError(f\"Input path {input_path} does not exist.\")\nif not Path(output_path).exists():\n    raise FileNotFoundError(f\"Output path {output_path} does not exist.\")\nif not Path(zarr_path).exists():\n    raise FileNotFoundError(f\"Logging path {zarr_path} does not exist.\")\n</pre> # Set directories base_dir = \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics\" input_path = base_dir output_path = Path(base_dir) / \"analysis\" logging_path = Path(output_path) / \"logging\" zarr_path = Path(input_path) / \"data/xenium.zarr\" area_path = Path(input_path) / \"data/section_one_cells.csv\"  # Confirm directories exist if not Path(input_path).exists():     raise FileNotFoundError(f\"Input path {input_path} does not exist.\") if not Path(output_path).exists():     raise FileNotFoundError(f\"Output path {output_path} does not exist.\") if not Path(zarr_path).exists():     raise FileNotFoundError(f\"Logging path {zarr_path} does not exist.\") In\u00a0[5]: Copied! <pre># Create output directories if they do not exist\nos.makedirs(Path(output_path) / module_name, exist_ok=True)\n\n# Set up logging\nos.makedirs(\n    logging_path, exist_ok=True\n)  # should set up all these directories at the start of the pipeline?\nlogging.basicConfig(\n    filename=Path(logging_path) / f\"{module_name}.txt\",  # output file\n    filemode=\"w\",  # overwrites the file each time\n    format=\"%(asctime)s - %(levelname)s - %(message)s\",  # log format\n    level=logging.INFO,  # minimum level to log\n)\n\n\n\n# change directory to output_path/module_name\nos.chdir(\n    Path(output_path) / module_name\n)  # need to so plots save in the correct directory\n</pre> # Create output directories if they do not exist os.makedirs(Path(output_path) / module_name, exist_ok=True)  # Set up logging os.makedirs(     logging_path, exist_ok=True )  # should set up all these directories at the start of the pipeline? logging.basicConfig(     filename=Path(logging_path) / f\"{module_name}.txt\",  # output file     filemode=\"w\",  # overwrites the file each time     format=\"%(asctime)s - %(levelname)s - %(message)s\",  # log format     level=logging.INFO,  # minimum level to log )    # change directory to output_path/module_name os.chdir(     Path(output_path) / module_name )  # need to so plots save in the correct directory In\u00a0[6]: Copied! <pre># Set colors\ncolor_map = sns.color_palette(\"crest\", as_cmap=True)\n</pre> # Set colors color_map = sns.color_palette(\"crest\", as_cmap=True) In\u00a0[7]: Copied! <pre># Import data\nlogging.info(\"Loading Xenium data...\")\nadata = sc.read_h5ad(Path(output_path) / \"4_view_images/adata.h5ad\")\nsdata = sd.read_zarr(zarr_path)\n</pre> # Import data logging.info(\"Loading Xenium data...\") adata = sc.read_h5ad(Path(output_path) / \"4_view_images/adata.h5ad\") sdata = sd.read_zarr(zarr_path) In\u00a0[8]: Copied! <pre># Import Xenium data using muspan\ntranscripts_of_interest = [\"EPCAM\", \"CD3D\", \"CD68\", \"VWF\", \"PTPRC\", \"ACTA2\"]\n\npc = ms.io.xenium_to_domain(\n    path_to_xenium_data=\"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/data/xenium\",\n    cells_from_selection_csv = area_path,\n    domain_name='A test domain',\n    load_transcripts=True,\n    selected_transcripts=transcripts_of_interest,\n    load_nuclei=True,\n    load_cells_as_shapes=True,\n    exclude_no_nuclei_cells=True)\n</pre> # Import Xenium data using muspan transcripts_of_interest = [\"EPCAM\", \"CD3D\", \"CD68\", \"VWF\", \"PTPRC\", \"ACTA2\"]  pc = ms.io.xenium_to_domain(     path_to_xenium_data=\"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/data/xenium\",     cells_from_selection_csv = area_path,     domain_name='A test domain',     load_transcripts=True,     selected_transcripts=transcripts_of_interest,     load_nuclei=True,     load_cells_as_shapes=True,     exclude_no_nuclei_cells=True) <pre>Domain name: A test domain\nNumber of objects: 7954\nCollections: ['Cell boundaries', 'Nucleus boundaries', 'Transcripts']\nLabels: ['Cell ID', 'Transcript Counts', 'Cell Area', 'Cluster ID', 'Nucleus Area', 'Transcript ID'] \nNetworks: [] \nDistance matrices: []\n</pre> In\u00a0[9]: Copied! <pre>print(pc)\n</pre> print(pc) <pre>Domain name: A test domain\nNumber of objects: 7954\nCollections: ['Cell boundaries', 'Nucleus boundaries', 'Transcripts']\nLabels: ['Cell ID', 'Transcript Counts', 'Cell Area', 'Cluster ID', 'Nucleus Area', 'Transcript ID'] \nNetworks: [] \nDistance matrices: []\n</pre> In\u00a0[10]: Copied! <pre>pc.collections['Transcripts']\n</pre> pc.collections['Transcripts'] Out[10]: <pre>{'collection_name': 'Transcripts',\n 'collection_name_integer': 2,\n 'objects': array([2866., 2867., 2868., ..., 7951., 7952., 7953.])}</pre> In\u00a0[11]: Copied! <pre># Queries to isolate the different objects within the MuSpAn domain\n\n# Query to isolate cell boundaries\nqCells = ms.query.query(pc, ('Collection',), 'is', 'Cell boundaries')\n\n# Query to isolate transcripts\nqTrans = ms.query.query(pc, ('Collection',), 'is', 'Transcripts')\n\n# Query to isolate nucleus boundaries\nqNuc = ms.query.query(pc, ('Collection',), 'is', 'Nucleus boundaries')\n</pre> # Queries to isolate the different objects within the MuSpAn domain  # Query to isolate cell boundaries qCells = ms.query.query(pc, ('Collection',), 'is', 'Cell boundaries')  # Query to isolate transcripts qTrans = ms.query.query(pc, ('Collection',), 'is', 'Transcripts')  # Query to isolate nucleus boundaries qNuc = ms.query.query(pc, ('Collection',), 'is', 'Nucleus boundaries') In\u00a0[12]: Copied! <pre>print(pc.labels.keys())  # see all keys in the labels dictionary\n</pre> print(pc.labels.keys())  # see all keys in the labels dictionary <pre>dict_keys(['Cell ID', 'Transcript Counts', 'Cell Area', 'Cluster ID', 'Nucleus Area', 'Transcript ID'])\n</pre> In\u00a0[13]: Copied! <pre># Create a figure with 2x2 subplots\nfig, ax = plt.subplots(figsize=(20, 15), nrows=2, ncols=2)\n\n# Visualise all objects in the MuSpAn domain\nms.visualise.visualise(pc, ax=ax[0, 0], \n                       marker_size=0.05)\nax[0, 0].set_title('All objects')\n\n# Visualise cells, colored by 'Cluster ID'\nms.visualise.visualise(pc, \n                       color_by=('label', 'Cluster ID'), \n                       ax=ax[0, 1], \n                       objects_to_plot=qCells)\nax[0, 1].set_title('Cells')\n\n# Visualise transcripts, colored by 'Transcript'\nms.visualise.visualise(pc, \n                       color_by=('label', 'Transcript ID'), \n                       ax=ax[1, 0], \n                       objects_to_plot=qTrans, \n                       marker_size=5)\nax[1, 0].set_title('Transcripts')\n\n# Visualise nuclei, colored by 'Nucleus Area'\nms.visualise.visualise(pc, color_by=('label', 'Nucleus Area'),\n                       ax=ax[1, 1], \n                       objects_to_plot=qNuc, \n                       #vmin=20, \n                       #vmax=200\n                       )\nax[1, 1].set_title('Nuclei')\n</pre> # Create a figure with 2x2 subplots fig, ax = plt.subplots(figsize=(20, 15), nrows=2, ncols=2)  # Visualise all objects in the MuSpAn domain ms.visualise.visualise(pc, ax=ax[0, 0],                         marker_size=0.05) ax[0, 0].set_title('All objects')  # Visualise cells, colored by 'Cluster ID' ms.visualise.visualise(pc,                         color_by=('label', 'Cluster ID'),                         ax=ax[0, 1],                         objects_to_plot=qCells) ax[0, 1].set_title('Cells')  # Visualise transcripts, colored by 'Transcript' ms.visualise.visualise(pc,                         color_by=('label', 'Transcript ID'),                         ax=ax[1, 0],                         objects_to_plot=qTrans,                         marker_size=5) ax[1, 0].set_title('Transcripts')  # Visualise nuclei, colored by 'Nucleus Area' ms.visualise.visualise(pc, color_by=('label', 'Nucleus Area'),                        ax=ax[1, 1],                         objects_to_plot=qNuc,                         #vmin=20,                         #vmax=200                        ) ax[1, 1].set_title('Nuclei') Out[13]: <pre>Text(0.5, 1.0, 'Nuclei')</pre> In\u00a0[14]: Copied! <pre># Convert cell boundaries to cell centres (centroids)\npc.convert_objects(\n    population=('Collection', 'Cell boundaries'),\n    object_type='point',\n    conversion_method='centroids',\n    collection_name='Cell centroids',\n    inherit_collections=False\n)\n\n# Plot the cell centres with color based on 'Cluster ID'\nplt.figure(figsize=(10, 6))\nms.visualise.visualise(\n    pc,\n    objects_to_plot=('collection', 'Cell centroids'),\n    color_by='Cluster ID',\n    ax=plt.gca()\n)\n</pre> # Convert cell boundaries to cell centres (centroids) pc.convert_objects(     population=('Collection', 'Cell boundaries'),     object_type='point',     conversion_method='centroids',     collection_name='Cell centroids',     inherit_collections=False )  # Plot the cell centres with color based on 'Cluster ID' plt.figure(figsize=(10, 6)) ms.visualise.visualise(     pc,     objects_to_plot=('collection', 'Cell centroids'),     color_by='Cluster ID',     ax=plt.gca() ) Out[14]: <pre>(&lt;Figure size 1000x600 with 2 Axes&gt;, &lt;Axes: &gt;)</pre> In\u00a0[15]: Copied! <pre># Generate a Delaunay network on the 'Cell centroids' data\n# The network will be stored in the domain.networks dictionary with the name 'Delaunay CC'\ndel_network = ms.networks.generate_network(pc,\n                             network_name='Delaunay CC filtered',\n                             network_type='Delaunay',\n                             objects_as_nodes=('collection','Cell centroids'),\n                             min_edge_distance=0,\n                             max_edge_distance=20\n                             )\n</pre> # Generate a Delaunay network on the 'Cell centroids' data # The network will be stored in the domain.networks dictionary with the name 'Delaunay CC' del_network = ms.networks.generate_network(pc,                              network_name='Delaunay CC filtered',                              network_type='Delaunay',                              objects_as_nodes=('collection','Cell centroids'),                              min_edge_distance=0,                              max_edge_distance=20                              ) In\u00a0[16]: Copied! <pre>del_network = ms.networks.generate_network(pc,\n                             network_name='Delaunay CC unfiltered',\n                             network_type='Delaunay',\n                             objects_as_nodes=('collection','Cell centroids')\n                             )\n</pre> del_network = ms.networks.generate_network(pc,                              network_name='Delaunay CC unfiltered',                              network_type='Delaunay',                              objects_as_nodes=('collection','Cell centroids')                              ) In\u00a0[17]: Copied! <pre>list(del_network.edges(data=True))[0]\n</pre> list(del_network.edges(data=True))[0] Out[17]: <pre>(7954, 7974, {'Distance': 6.057404240397282, 'Inverse Distance': 1.0})</pre> In\u00a0[18]: Copied! <pre>print('Delaunay CC unfiltered:',pc.networks['Delaunay CC unfiltered'])\nprint('Delaunay CC filtered:',pc.networks['Delaunay CC filtered'])\n</pre> print('Delaunay CC unfiltered:',pc.networks['Delaunay CC unfiltered']) print('Delaunay CC filtered:',pc.networks['Delaunay CC filtered']) <pre>Delaunay CC unfiltered: Graph with 1433 nodes and 4282 edges\nDelaunay CC filtered: Graph with 1433 nodes and 4032 edges\n</pre> In\u00a0[19]: Copied! <pre># Create a 1x2 subplot for visualizing the original and filtered Delaunay networks\nfig, ax = plt.subplots(1, 2, figsize=(13, 6))\n\n# Plot the original Delaunay network\nax[0].set_title('Delaunay CC unfiltered')\nms.visualise.visualise_network(\n    pc,\n    network_name='Delaunay CC unfiltered',\n    ax=ax[0],\n    edge_weight_name=None,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), marker_size=15, add_cbar=False)\n)\n\n# Plot the filtered Delaunay network\nax[1].set_title('Delaunay CC filtered')\nms.visualise.visualise_network(\n    pc,\n    network_name='Delaunay CC filtered',\n    ax=ax[1],\n    edge_weight_name=None,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), marker_size=15, add_cbar=False)\n)\n</pre> # Create a 1x2 subplot for visualizing the original and filtered Delaunay networks fig, ax = plt.subplots(1, 2, figsize=(13, 6))  # Plot the original Delaunay network ax[0].set_title('Delaunay CC unfiltered') ms.visualise.visualise_network(     pc,     network_name='Delaunay CC unfiltered',     ax=ax[0],     edge_weight_name=None,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), marker_size=15, add_cbar=False) )  # Plot the filtered Delaunay network ax[1].set_title('Delaunay CC filtered') ms.visualise.visualise_network(     pc,     network_name='Delaunay CC filtered',     ax=ax[1],     edge_weight_name=None,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), marker_size=15, add_cbar=False) ) Out[19]: <pre>(&lt;Figure size 1300x600 with 2 Axes&gt;,\n &lt;Axes: title={'center': 'Delaunay CC filtered'}&gt;)</pre> In\u00a0[20]: Copied! <pre># Generate proximity networks with different maximum edge distances\n\n# Proximity network with 10\u03bcm max distance\nms.networks.generate_network(\n    pc,\n    network_name='prox network centroids 10',\n    network_type='Proximity',\n    objects_as_nodes=('collection', 'Cell centroids'),\n    max_edge_distance=10,\n    min_edge_distance=0\n)\n\n# Proximity network with 30\u03bcm max distance\nms.networks.generate_network(\n    pc,\n    network_name='prox network centroids 30',\n    network_type='Proximity',\n    objects_as_nodes=('collection', 'Cell centroids'),\n    max_edge_distance=30,\n    min_edge_distance=0\n)\n\n# Proximity network with 50\u03bcm max distance\nms.networks.generate_network(\n    pc,\n    network_name='prox network centroids 50',\n    network_type='Proximity',\n    objects_as_nodes=('collection', 'Cell centroids'),\n    max_edge_distance=50,\n    min_edge_distance=0\n)\n</pre> # Generate proximity networks with different maximum edge distances  # Proximity network with 10\u03bcm max distance ms.networks.generate_network(     pc,     network_name='prox network centroids 10',     network_type='Proximity',     objects_as_nodes=('collection', 'Cell centroids'),     max_edge_distance=10,     min_edge_distance=0 )  # Proximity network with 30\u03bcm max distance ms.networks.generate_network(     pc,     network_name='prox network centroids 30',     network_type='Proximity',     objects_as_nodes=('collection', 'Cell centroids'),     max_edge_distance=30,     min_edge_distance=0 )  # Proximity network with 50\u03bcm max distance ms.networks.generate_network(     pc,     network_name='prox network centroids 50',     network_type='Proximity',     objects_as_nodes=('collection', 'Cell centroids'),     max_edge_distance=50,     min_edge_distance=0 ) Out[20]: <pre>&lt;networkx.classes.graph.Graph at 0x14bc43370&gt;</pre> In\u00a0[33]: Copied! <pre># Create a figure with 3 subplots arranged in a single row\nfig, ax = plt.subplots(1, 3, figsize=(25, 6), gridspec_kw={'width_ratios': [1, 1, 1.8]})\n\n# Plot the proximity network with 10\u03bcm max distance\nax[0].set_title('Proximity network: 10\u03bcm max distance')\nms.visualise.visualise_network(\n    pc,\n    network_name='prox network centroids 10',\n    ax=ax[0],\n    edge_cmap=color_map,\n    edge_vmin=0,\n    edge_vmax=50,\n    add_cbar=False,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), \n                          marker_size=15,\n                          color_by=('constant','black'))\n)\n\n# Plot the proximity network with 30\u03bcm max distance\nax[1].set_title('Proximity network: 30\u03bcm max distance')\nms.visualise.visualise_network(\n    pc,\n    network_name='prox network centroids 30',\n    ax=ax[1],\n    edge_cmap=color_map,\n    edge_vmin=0,\n    edge_vmax=50,\n    add_cbar=False,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), \n                          marker_size=15,\n                          color_by=('constant','black'))\n)\n\n# Plot the proximity network with 50\u03bcm max distance\nax[2].set_title('Proximity network: 50\u03bcm max distance')\nms.visualise.visualise_network(\n    pc,\n    network_name='prox network centroids 50',\n    ax=ax[2],\n    edge_cmap=color_map,\n    edge_vmin=0,\n    edge_vmax=50,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), \n                          marker_size=15, \n                          color_by=('constant','black'))\n)\n</pre> # Create a figure with 3 subplots arranged in a single row fig, ax = plt.subplots(1, 3, figsize=(25, 6), gridspec_kw={'width_ratios': [1, 1, 1.8]})  # Plot the proximity network with 10\u03bcm max distance ax[0].set_title('Proximity network: 10\u03bcm max distance') ms.visualise.visualise_network(     pc,     network_name='prox network centroids 10',     ax=ax[0],     edge_cmap=color_map,     edge_vmin=0,     edge_vmax=50,     add_cbar=False,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),                            marker_size=15,                           color_by=('constant','black')) )  # Plot the proximity network with 30\u03bcm max distance ax[1].set_title('Proximity network: 30\u03bcm max distance') ms.visualise.visualise_network(     pc,     network_name='prox network centroids 30',     ax=ax[1],     edge_cmap=color_map,     edge_vmin=0,     edge_vmax=50,     add_cbar=False,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),                            marker_size=15,                           color_by=('constant','black')) )  # Plot the proximity network with 50\u03bcm max distance ax[2].set_title('Proximity network: 50\u03bcm max distance') ms.visualise.visualise_network(     pc,     network_name='prox network centroids 50',     ax=ax[2],     edge_cmap=color_map,     edge_vmin=0,     edge_vmax=50,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),                            marker_size=15,                            color_by=('constant','black')) ) Out[33]: <pre>(&lt;Figure size 2500x600 with 4 Axes&gt;,\n &lt;Axes: title={'center': 'Proximity network: 50\u03bcm max distance'}&gt;)</pre> In\u00a0[22]: Copied! <pre># Generate a proximity network from shape-like objects (Cell boundaries)\n# with a maximum edge distance of 1.5\u03bcm\n\nms.networks.generate_network(\n    pc,\n    network_name='Contact network',\n    network_type='Proximity',\n    objects_as_nodes=('collection', 'Cell boundaries'),\n    max_edge_distance=10,\n    min_edge_distance=0\n)\n</pre> # Generate a proximity network from shape-like objects (Cell boundaries) # with a maximum edge distance of 1.5\u03bcm  ms.networks.generate_network(     pc,     network_name='Contact network',     network_type='Proximity',     objects_as_nodes=('collection', 'Cell boundaries'),     max_edge_distance=10,     min_edge_distance=0 ) Out[22]: <pre>&lt;networkx.classes.graph.Graph at 0x168620340&gt;</pre> In\u00a0[\u00a0]: Copied! <pre># Create a figure with a single subplot\nfig, ax = plt.subplots(1, 1, figsize=(12, 10))\n\n# Plot the cell boundaries underneath the network\nms.visualise.visualise(\n    pc,\n    ax=ax,\n    objects_to_plot=('collection', 'Cell boundaries'),\n    marker_size=15,\n    add_cbar=False,\n    shape_kwargs={'color': '#4D7EAB', \n                  'alpha': 0.1, \n                  'edgecolor': 'black'},\n)\n\n# Plot the contact network on top of the cell boundaries\nms.visualise.visualise_network(\n    pc,\n    network_name='Contact network',\n    ax=ax,\n    edge_weight_name=None,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), \n                          marker_size=10,\n                          color_by=('constant','black')\n                        )\n)\n</pre> # Create a figure with a single subplot fig, ax = plt.subplots(1, 1, figsize=(12, 10))  # Plot the cell boundaries underneath the network ms.visualise.visualise(     pc,     ax=ax,     objects_to_plot=('collection', 'Cell boundaries'),     marker_size=15,     add_cbar=False,     shape_kwargs={'color': '#4D7EAB',                    'alpha': 0.1,                    'edgecolor': 'black'}, )  # Plot the contact network on top of the cell boundaries ms.visualise.visualise_network(     pc,     network_name='Contact network',     ax=ax,     edge_weight_name=None,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),                            marker_size=10,                           color_by=('constant','black')                         ) ) Out[\u00a0]: <pre>(&lt;Figure size 1200x1000 with 1 Axes&gt;, &lt;Axes: &gt;)</pre> <p>Network_method argument and defining the number of neighbours we\u2019d like to connect for every node using the number_of_nearest_neighbours parameter</p> In\u00a0[24]: Copied! <pre># Generate a K-Nearest Neighbours (KNN) network on the 'Cell centroids' data with k neighbors\nk = 10\n\nms.networks.generate_network(\n    pc,\n    network_name=f\"{k}-NN network\",\n    network_type='KNN',\n    objects_as_nodes=('collection', 'Cell centroids'),\n    number_of_nearest_neighbours=k\n)\n</pre> # Generate a K-Nearest Neighbours (KNN) network on the 'Cell centroids' data with k neighbors k = 10  ms.networks.generate_network(     pc,     network_name=f\"{k}-NN network\",     network_type='KNN',     objects_as_nodes=('collection', 'Cell centroids'),     number_of_nearest_neighbours=k ) Out[24]: <pre>&lt;networkx.classes.digraph.DiGraph at 0x14bc13cd0&gt;</pre> In\u00a0[25]: Copied! <pre># Create a figure and axis for plotting the KNN network\nfig, ax = plt.subplots(1, 1, figsize=(10, 6))\n\n# Visualise the 10-NN network on the 'Cell centroids' data\nms.visualise.visualise_network(\n    pc,\n    network_name=f\"{k}-NN network\",\n    ax=ax,\n    edge_weight_name='Distance',\n    edge_cmap=color_map,\n    visualise_kwargs=dict(\n        objects_to_plot=('collection', 'Cell centroids'),\n        marker_size=15\n    )\n)\n</pre> # Create a figure and axis for plotting the KNN network fig, ax = plt.subplots(1, 1, figsize=(10, 6))  # Visualise the 10-NN network on the 'Cell centroids' data ms.visualise.visualise_network(     pc,     network_name=f\"{k}-NN network\",     ax=ax,     edge_weight_name='Distance',     edge_cmap=color_map,     visualise_kwargs=dict(         objects_to_plot=('collection', 'Cell centroids'),         marker_size=15     ) ) Out[25]: <pre>(&lt;Figure size 1000x600 with 3 Axes&gt;, &lt;Axes: &gt;)</pre> <p>We can see that each object should be connected to only 10 other objects in our domain</p> In\u00a0[26]: Copied! <pre># Initialize an empty list to store the number of neighbours for each node\nnumber_of_neighbours_check = []\n\n# Iterate through each node in the 'f\"{k}-NN network\"k'\nfor node in pc.networks[f\"{k}-NN network\"].nodes():\n    # Append the number of neighbours for the current node to the list\n    number_of_neighbours_check.append(len(list(pc.networks[f\"{k}-NN network\"].neighbors(node))))\n\n# Print the number of adjacent nodes for the first 100 nodes\nprint('Number of adjacent nodes for the first 100 nodes:', number_of_neighbours_check[:100])\n</pre> # Initialize an empty list to store the number of neighbours for each node number_of_neighbours_check = []  # Iterate through each node in the 'f\"{k}-NN network\"k' for node in pc.networks[f\"{k}-NN network\"].nodes():     # Append the number of neighbours for the current node to the list     number_of_neighbours_check.append(len(list(pc.networks[f\"{k}-NN network\"].neighbors(node))))  # Print the number of adjacent nodes for the first 100 nodes print('Number of adjacent nodes for the first 100 nodes:', number_of_neighbours_check[:100]) <pre>Number of adjacent nodes for the first 100 nodes: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]\n</pre> In\u00a0[27]: Copied! <pre># Query the domain for points of Celltype D\npop_8 = ms.query.query(pc, ('label', 'Cluster ID'), 'is', 'Cluster 8')\n\n# Calculate the cross-PCF for points of Celltype D with themselves\n# max_R: maximum radius to consider\n# annulus_step: step size for the annulus\n# annulus_width: width of the annulus\n# visualise_output: whether to visualise the output\nr, PCF = ms.spatial_statistics.cross_pair_correlation_function(\n    domain=pc,\n    population_A=pop_8,\n    population_B=pop_8,\n    max_R=200,\n    annulus_step=5,\n    annulus_width=25,\n    visualise_output=True\n)\n</pre> # Query the domain for points of Celltype D pop_8 = ms.query.query(pc, ('label', 'Cluster ID'), 'is', 'Cluster 8')  # Calculate the cross-PCF for points of Celltype D with themselves # max_R: maximum radius to consider # annulus_step: step size for the annulus # annulus_width: width of the annulus # visualise_output: whether to visualise the output r, PCF = ms.spatial_statistics.cross_pair_correlation_function(     domain=pc,     population_A=pop_8,     population_B=pop_8,     max_R=200,     annulus_step=5,     annulus_width=25,     visualise_output=True ) In\u00a0[28]: Copied! <pre>celltypes = pc.labels['Cluster ID']['labels'].tolist()\ncelltypes = np.unique(celltypes)\nlen(celltypes)\n</pre> celltypes = pc.labels['Cluster ID']['labels'].tolist() celltypes = np.unique(celltypes) len(celltypes) Out[28]: <pre>20</pre> In\u00a0[29]: Copied! <pre># Define the cell types to be analyzed\ncelltypes = pc.labels['Cluster ID']['labels'].tolist()\ncelltypes = np.unique(celltypes)\n\n# Create a 4x4 subplot for visualizing the cross-PCF for each combination of cell types\nfig, axes = plt.subplots(20, 20, figsize=(12, 12))\n\n# Loop through each combination of cell types\nfor i in range(len(celltypes)):\n    for j in range(len(celltypes)):\n        pop_A = ms.query.query(pc, ('label', 'Cluster ID'), 'is', celltypes[i])\n        pop_B = ms.query.query(pc, ('label', 'Cluster ID'), 'is', celltypes[j])\n        r, PCF = ms.spatial_statistics.cross_pair_correlation_function(\n            pc,\n            pop_A,\n            pop_B,\n            max_R=200,\n            annulus_step=5,\n            annulus_width=25\n        )\n\n        # Select the current subplot\n        ax = axes[i, j]\n\n        # Plot the cross-PCF\n        ax.plot(r, PCF)\n\n        # Add a horizontal line at y=1 to indicate the CSR baseline\n        ax.axhline(1, color='k', linestyle=':')\n\n        # Set the y-axis limit\n        ax.set_ylim([0, 7])\n\n        # Label the y-axis with the cross-PCF notation\n        ax.set_ylabel(f'$g_{{{celltypes[i]}{celltypes[j]}}}(r)$')\n\n        # Label the x-axis with the distance r\n        ax.set_xlabel('$r$')\n\n# Adjust the layout to prevent overlap\nplt.tight_layout()\n</pre> # Define the cell types to be analyzed celltypes = pc.labels['Cluster ID']['labels'].tolist() celltypes = np.unique(celltypes)  # Create a 4x4 subplot for visualizing the cross-PCF for each combination of cell types fig, axes = plt.subplots(20, 20, figsize=(12, 12))  # Loop through each combination of cell types for i in range(len(celltypes)):     for j in range(len(celltypes)):         pop_A = ms.query.query(pc, ('label', 'Cluster ID'), 'is', celltypes[i])         pop_B = ms.query.query(pc, ('label', 'Cluster ID'), 'is', celltypes[j])         r, PCF = ms.spatial_statistics.cross_pair_correlation_function(             pc,             pop_A,             pop_B,             max_R=200,             annulus_step=5,             annulus_width=25         )          # Select the current subplot         ax = axes[i, j]          # Plot the cross-PCF         ax.plot(r, PCF)          # Add a horizontal line at y=1 to indicate the CSR baseline         ax.axhline(1, color='k', linestyle=':')          # Set the y-axis limit         ax.set_ylim([0, 7])          # Label the y-axis with the cross-PCF notation         ax.set_ylabel(f'$g_{{{celltypes[i]}{celltypes[j]}}}(r)$')          # Label the x-axis with the distance r         ax.set_xlabel('$r$')  # Adjust the layout to prevent overlap plt.tight_layout() In\u00a0[31]: Copied! <pre># Query population A from the domain\npopA = ms.query.query(pc, ('label', 'Cluster ID'), 'is', 'Cluster 8')\n\n# Query population B from the domain\npopB = ms.query.query(pc, ('label', 'Cluster ID'), 'is', 'Cluster 2')\n\n# Calculate the weighted pair correlation function (wPCF)\n# Parameters:\n# - domain: the domain containing the points\n# - popA: the first population of points (A)\n# - popB: the second population of points (B)\n# - mark_pop_B: the label/mark associated with population B\n# - max_R: the maximum radius to consider for the wPCF\n# - annulus_step: the step size for the annulus radii\n# - annulus_width: the width of each annulus\nradii, wPCF = ms.spatial_statistics.weighted_pair_correlation_function(\n    pc, \n    popA, \n    popB, \n    mark_pop_B='Mark', \n    max_R=1, \n    annulus_step=0.1, \n    annulus_width=0.15\n)\n</pre> # Query population A from the domain popA = ms.query.query(pc, ('label', 'Cluster ID'), 'is', 'Cluster 8')  # Query population B from the domain popB = ms.query.query(pc, ('label', 'Cluster ID'), 'is', 'Cluster 2')  # Calculate the weighted pair correlation function (wPCF) # Parameters: # - domain: the domain containing the points # - popA: the first population of points (A) # - popB: the second population of points (B) # - mark_pop_B: the label/mark associated with population B # - max_R: the maximum radius to consider for the wPCF # - annulus_step: the step size for the annulus radii # - annulus_width: the width of each annulus radii, wPCF = ms.spatial_statistics.weighted_pair_correlation_function(     pc,      popA,      popB,      mark_pop_B='Mark',      max_R=1,      annulus_step=0.1,      annulus_width=0.15 ) <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In [31], line 16\n      5 popB = ms.query.query(pc, ('label', 'Cluster ID'), 'is', 'Cluster 2')\n      7 # Calculate the weighted pair correlation function (wPCF)\n      8 # Parameters:\n      9 # - domain: the domain containing the points\n   (...)\n     14 # - annulus_step: the step size for the annulus radii\n     15 # - annulus_width: the width of each annulus\n---&gt; 16 radii, wPCF = ms.spatial_statistics.weighted_pair_correlation_function(\n     17     pc, \n     18     popA, \n     19     popB, \n     20     mark_pop_B='Mark', \n     21     max_R=1, \n     22     annulus_step=0.1, \n     23     annulus_width=0.15\n     24 )\n\nFile /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/muspan/spatial_statistics/weighted_pair_correlation_function.py:124, in weighted_pair_correlation_function(domain, population_A, population_B, mark_pop_B, include_boundaries, exclude_boundaries, boundary_exclude_distance, weighting_function_pop_B, mark_step_pop_B, mark_min_pop_B, mark_max_pop_B, distance_metric, max_R, annulus_step, annulus_width, exclude_zero, remain_within_connected_component, visualise_output, visualise_wpcf_kwargs)\n    121     get_weights = weighting_function_pop_B\n    123 # Get the marks associated with points in p_B\n--&gt; 124 if domain.labels[mark_pop_B]['labelType'] != 'continuous':\n    125     raise ValueError(f\"mark_pop_B should refer to a continuous label; the label {mark_pop_B} is {domain.labels[mark_pop_B]['labelType']}\")\n    126 all_marks, ois = get_labels(domain, mark_pop_B)\n\nKeyError: 'Mark'</pre>"},{"location":"sample/#creating-spatial-networks","title":"Creating spatial networks\u00b6","text":""},{"location":"sample/#delaunay-networks-from-point-like-data","title":"Delaunay networks from point-like data\u00b6","text":"<p>If no boundary information about our spatial objects is given in our dataset (i.e., no segmentation mask), then Deluanay networks on point-like data are a common approximation of the local connectivity of the data. It\u2019s construction is based on area (volume) filling process between all points such that edges are generated to produce triangles that do not contain any other point, therefore an edge between points presents the adjacency of the voronoi cells of the data.</p> <p>Edge weights are values that can be used to describe the connectivity between nodes.</p>"},{"location":"sample/#proximity-based-networks","title":"Proximity based networks\u00b6","text":"<p>Proximity networks are purely distance-based networks. Formally, in a Proximity network, any two nodes are connected if the distance between is within a specified range, which is defined in our case by max_edge_distance and min_edge_distance. These networks are particularly useful in spatial analysis where the physical distance between objects is a key factor. By adjusting the distance thresholds, we can explore how connectivity changes at different spatial scales. This can help in understanding the spatial organization and interactions within the dataset.</p>"},{"location":"sample/#point-like-objects","title":"Point-like objects\u00b6","text":""},{"location":"sample/#shape-like-objects","title":"Shape-like objects\u00b6","text":"<p>Note that the \u2018Contact network\u2019 is defined between the \u2018Cell boundary\u2019 objects but edges will be drawn from their centroids. For purely visualisation purposes, we include the \u2018Cell centroids\u2019 on the plot.</p>"},{"location":"sample/#knn-based-networks","title":"KNN based networks\u00b6","text":""},{"location":"sample/#spatial-analysis","title":"Spatial analysis\u00b6","text":""},{"location":"sample/#cross-pair-correlation-function-cross-pcf","title":"Cross pair correlation function (cross-PCF)\u00b6","text":"<p>The cross pair correlation function (cross-PCF, also known as the Radial Distribution Function) is a spatial statistic that characterises clustering or exclusion at different length scales. Consider two populations of points, that we\u2019ll call and . Then the cross-PCF, , can be thought of as a ratio describing whether the observed number of pairs of points separated by distance (where one is type and the other type ) is higher or lower than would be expected under a statistical null model. In brief, indicates increased numbers of pairs separated by distance , which indicates clustering. suggests exclusion, or regularity.</p>"},{"location":"sample/#the-weighted-pair-correlation-function-wpcf","title":"The weighted pair correlation function (wPCF)\u00b6","text":"<p>The weighted pair correlation function (wPCF) is a spatial statistic that extends the standard pair correlation function to identify spatial relationships between two point populations, one of which is labelled with a continuous mark. For full details, see https://doi.org/10.1371/journal.pcbi.1010994 or https://doi.org/10.1017/S2633903X24000011.</p> <p>In this tutorial, we briefly reproduce the example from Figure 3 of Quantification of spatial and phenotypic heterogeneity in an agent-based model of tumour-macrophage interactions (PLOS Computational Biology 19(3) https://doi.org/10.1371/journal.pcbi.1010994). We start by placing a line of points from population across the line , and a second population placed randomly across the domain. Population points are assigned a mark</p>"},{"location":"sample/#spatial-autocorrelation-hotspot-analysis","title":"Spatial Autocorrelation (Hotspot Analysis)\u00b6","text":""},{"location":"sample/#spatial-statistics","title":"Spatial statistics\u00b6","text":""},{"location":"sample/#spatial-netork-analysis","title":"Spatial Netork Analysis\u00b6","text":""},{"location":"sample/#topological-data-analysis","title":"Topological Data Analysis\u00b6","text":""},{"location":"sample/#distribution-analysis","title":"Distribution Analysis\u00b6","text":""},{"location":"sample/#quantifying-morphology","title":"Quantifying Morphology\u00b6","text":""},{"location":"sample_regis/","title":"Creating spatial networks","text":"In\u00a0[\u00a0]: Copied! <pre># Import packages\nimport logging\nimport os\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nimport muspan as ms\nimport numpy as np\nimport scanpy as sc\nimport squidpy as sq\nimport seaborn as sns\nimport pandas as pd\n</pre> # Import packages import logging import os from pathlib import Path  import matplotlib.pyplot as plt import muspan as ms import numpy as np import scanpy as sc import squidpy as sq import seaborn as sns import pandas as pd <pre>\nA module that was compiled using NumPy 1.x cannot be run in\nNumPy 2.2.6 as it may crash. To support both 1.x and 2.x\nversions of NumPy, modules must be compiled with NumPy 2.0.\nSome module may need to rebuild instead e.g. with 'pybind11&gt;=2.12'.\n\nIf you are a user of the module, the easiest solution will be to\ndowngrade to 'numpy&lt;2' or try to upgrade the affected module.\nWe expect that some modules will need time to support NumPy 2.\n\nTraceback (most recent call last):  File \"&lt;frozen runpy&gt;\", line 198, in _run_module_as_main\n  File \"&lt;frozen runpy&gt;\", line 88, in _run_code\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ipykernel_launcher.py\", line 18, in &lt;module&gt;\n    app.launch_new_instance()\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/traitlets/config/application.py\", line 1075, in launch_instance\n    app.start()\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ipykernel/kernelapp.py\", line 739, in start\n    self.io_loop.start()\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/tornado/platform/asyncio.py\", line 211, in start\n    self.asyncio_loop.run_forever()\n  File \"/Users/sarapatti/miniforge3/lib/python3.12/asyncio/base_events.py\", line 641, in run_forever\n    self._run_once()\n  File \"/Users/sarapatti/miniforge3/lib/python3.12/asyncio/base_events.py\", line 1986, in _run_once\n    handle._run()\n  File \"/Users/sarapatti/miniforge3/lib/python3.12/asyncio/events.py\", line 88, in _run\n    self._context.run(self._callback, *self._args)\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ipykernel/kernelbase.py\", line 545, in dispatch_queue\n    await self.process_one()\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ipykernel/kernelbase.py\", line 534, in process_one\n    await dispatch(*args)\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ipykernel/kernelbase.py\", line 437, in dispatch_shell\n    await result\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ipykernel/ipkernel.py\", line 362, in execute_request\n    await super().execute_request(stream, ident, parent)\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ipykernel/kernelbase.py\", line 778, in execute_request\n    reply_content = await reply_content\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ipykernel/ipkernel.py\", line 449, in do_execute\n    res = shell.run_cell(\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ipykernel/zmqshell.py\", line 549, in run_cell\n    return super().run_cell(*args, **kwargs)\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/IPython/core/interactiveshell.py\", line 3100, in run_cell\n    result = self._run_cell(\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/IPython/core/interactiveshell.py\", line 3155, in _run_cell\n    result = runner(coro)\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/IPython/core/async_helpers.py\", line 128, in _pseudo_sync_runner\n    coro.send(None)\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/IPython/core/interactiveshell.py\", line 3367, in run_cell_async\n    has_raised = await self.run_ast_nodes(code_ast.body, cell_name,\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/IPython/core/interactiveshell.py\", line 3612, in run_ast_nodes\n    if await self.run_code(code, result, async_=asy):\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/IPython/core/interactiveshell.py\", line 3672, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n  File \"/var/folders/yq/6fgvx0fj0cs57zmqydzbhbfh0000gn/T/ipykernel_44779/2125299851.py\", line 7, in &lt;module&gt;\n    import muspan as ms\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/muspan/__init__.py\", line 15, in &lt;module&gt;\n    from . import distribution\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/muspan/distribution/__init__.py\", line 6, in &lt;module&gt;\n    from .sliced_wasserstein_distance import sliced_wasserstein_distance\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/muspan/distribution/sliced_wasserstein_distance.py\", line 5, in &lt;module&gt;\n    import ot\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ot/__init__.py\", line 20, in &lt;module&gt;\n    from . import lp\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ot/lp/__init__.py\", line 16, in &lt;module&gt;\n    from .dmmot import dmmot_monge_1dgrid_loss, dmmot_monge_1dgrid_optimize\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ot/lp/dmmot.py\", line 12, in &lt;module&gt;\n    from ..backend import get_backend\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/ot/backend.py\", line 107, in &lt;module&gt;\n    import torch\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/torch/__init__.py\", line 1477, in &lt;module&gt;\n    from .functional import *  # noqa: F403\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/torch/functional.py\", line 9, in &lt;module&gt;\n    import torch.nn.functional as F\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/torch/nn/__init__.py\", line 1, in &lt;module&gt;\n    from .modules import *  # noqa: F403\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/torch/nn/modules/__init__.py\", line 35, in &lt;module&gt;\n    from .transformer import TransformerEncoder, TransformerDecoder, \\\n  File \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/torch/nn/modules/transformer.py\", line 20, in &lt;module&gt;\n    device: torch.device = torch.device(torch._C._get_default_device()),  # torch.device('cpu'),\n</pre> <pre>\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In[1], line 10\n      8 import numpy as np\n      9 import scanpy as sc\n---&gt; 10 import spatialdata as sd\n     11 import squidpy as sq\n     12 import seaborn as sns\n\nFile ~/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/spatialdata/__init__.py:58\n     20 __version__ = version(\"spatialdata\")\n     22 __all__ = [\n     23     \"models\",\n     24     \"transformations\",\n   (...)     55     \"deepcopy\",\n     56 ]\n---&gt; 58 from spatialdata import dataloader, datasets, models, transformations\n     59 from spatialdata._core._deepcopy import deepcopy\n     60 from spatialdata._core.centroids import get_centroids\n\nFile ~/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/spatialdata/dataloader/__init__.py:2\n      1 try:\n----&gt; 2     from spatialdata.dataloader.datasets import ImageTilesDataset\n      3 except ImportError:\n      4     ImageTilesDataset = None  # type: ignore[assignment, misc]\n\nFile ~/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/spatialdata/dataloader/datasets.py:14\n     12 import pandas as pd\n     13 from anndata import AnnData\n---&gt; 14 from geopandas import GeoDataFrame\n     15 from pandas import CategoricalDtype\n     16 from scipy.sparse import issparse\n\nFile ~/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/geopandas/__init__.py:3\n      1 from geopandas._config import options\n----&gt; 3 from geopandas.geoseries import GeoSeries\n      4 from geopandas.geodataframe import GeoDataFrame\n      5 from geopandas.array import points_from_xy\n\nFile ~/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/geopandas/geoseries.py:17\n     14 from shapely.geometry.base import BaseGeometry\n     16 import geopandas\n---&gt; 17 from geopandas.base import GeoPandasBase, _delegate_property\n     18 from geopandas.explore import _explore_geoseries\n     19 from geopandas.plotting import plot_series\n\nFile ~/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/geopandas/base.py:11\n      8 from shapely.geometry import MultiPoint, box\n      9 from shapely.geometry.base import BaseGeometry\n---&gt; 11 from . import _compat as compat\n     12 from .array import GeometryArray, GeometryDtype, points_from_xy\n     15 def is_geometry_type(data):\n\nFile ~/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/geopandas/_compat.py:67\n     63 # -----------------------------------------------------------------------------\n     64 # pyproj compat\n     65 # -----------------------------------------------------------------------------\n     66 try:\n---&gt; 67     import pyproj  # noqa: F401\n     69     HAS_PYPROJ = True\n     71 except ImportError as err:\n\nFile ~/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/pyproj/__init__.py:34\n      1 \"\"\"\n      2 Python interface to PROJ (https://proj.org),\n      3 cartographic projections and coordinate transformations library.\n   (...)     29 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n     30 \"\"\"\n     32 import warnings\n---&gt; 34 import pyproj.network\n     35 from pyproj._context import (  # noqa: F401 pylint: disable=unused-import\n     36     set_use_global_context,\n     37 )\n     38 from pyproj._show_versions import (  # noqa: F401 pylint: disable=unused-import\n     39     show_versions,\n     40 )\n\nFile ~/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics/.venv/lib/python3.12/site-packages/pyproj/network.py:10\n      6 from pathlib import Path\n      8 import certifi\n---&gt; 10 from pyproj._context import _set_context_ca_bundle_path\n     11 from pyproj._network import (  # noqa: F401 pylint: disable=unused-import\n     12     is_network_enabled,\n     13     set_network_enabled,\n     14 )\n     17 def set_ca_bundle_path(ca_bundle_path: Path | str | bool | None = None) -&gt; None:\n\nFile &lt;frozen importlib._bootstrap&gt;:645, in parent(self)\n\nKeyboardInterrupt: </pre> In\u00a0[5]: Copied! <pre># Set variables\nmodule_name = \"6_muspan\"  # name of the module\n</pre> # Set variables module_name = \"6_muspan\"  # name of the module In\u00a0[6]: Copied! <pre># Set directories\nbase_dir = \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics\"\ninput_path = base_dir\noutput_path = Path(base_dir) / \"analysis\"\nlogging_path = Path(output_path) / \"logging\"\nzarr_path = Path(input_path) / \"data/xenium.zarr\"\n\n# Confirm directories exist\nif not Path(input_path).exists():\n    raise FileNotFoundError(f\"Input path {input_path} does not exist.\")\nif not Path(output_path).exists():\n    raise FileNotFoundError(f\"Output path {output_path} does not exist.\")\nif not Path(zarr_path).exists():\n    raise FileNotFoundError(f\"Logging path {zarr_path} does not exist.\")\n</pre> # Set directories base_dir = \"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ReCoDe-spatial-transcriptomics\" input_path = base_dir output_path = Path(base_dir) / \"analysis\" logging_path = Path(output_path) / \"logging\" zarr_path = Path(input_path) / \"data/xenium.zarr\"  # Confirm directories exist if not Path(input_path).exists():     raise FileNotFoundError(f\"Input path {input_path} does not exist.\") if not Path(output_path).exists():     raise FileNotFoundError(f\"Output path {output_path} does not exist.\") if not Path(zarr_path).exists():     raise FileNotFoundError(f\"Logging path {zarr_path} does not exist.\") In\u00a0[7]: Copied! <pre># Create output directories if they do not exist\nos.makedirs(Path(output_path) / module_name, exist_ok=True)\n\n# Set up logging\nos.makedirs(\n    logging_path, exist_ok=True\n)  # should set up all these directories at the start of the pipeline?\nlogging.basicConfig(\n    filename=Path(logging_path) / f\"{module_name}.txt\",  # output file\n    filemode=\"w\",  # overwrites the file each time\n    format=\"%(asctime)s - %(levelname)s - %(message)s\",  # log format\n    level=logging.INFO,  # minimum level to log\n)\n\n\n# change directory to output_path/module_name\nos.chdir(\n    Path(output_path) / module_name\n)  # need to so plots save in the correct directory\n</pre> # Create output directories if they do not exist os.makedirs(Path(output_path) / module_name, exist_ok=True)  # Set up logging os.makedirs(     logging_path, exist_ok=True )  # should set up all these directories at the start of the pipeline? logging.basicConfig(     filename=Path(logging_path) / f\"{module_name}.txt\",  # output file     filemode=\"w\",  # overwrites the file each time     format=\"%(asctime)s - %(levelname)s - %(message)s\",  # log format     level=logging.INFO,  # minimum level to log )   # change directory to output_path/module_name os.chdir(     Path(output_path) / module_name )  # need to so plots save in the correct directory In\u00a0[8]: Copied! <pre># Set colors\ncolor_map = sns.color_palette(\"Blues\", as_cmap=True)\n</pre> # Set colors color_map = sns.color_palette(\"Blues\", as_cmap=True) In\u00a0[9]: Copied! <pre># Load data\nadata = sc.read_h5ad(\"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ST_Xenium_Asthma/analysis/h5ad/xenium_annotated.h5ad\")\n</pre> # Load data adata = sc.read_h5ad(\"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ST_Xenium_Asthma/analysis/h5ad/xenium_annotated.h5ad\") In\u00a0[10]: Copied! <pre># Import Regis' cluster labeling\nmatrix_epi = pd.read_excel(\"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ST_Regis_analysis/data/Cell_matrices_D2C/matrix_epithelium_total_filter_asthma.xlsx\")\nmatrix_muc = pd.read_excel(\"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ST_Regis_analysis/data/Cell_matrices_D2C/Matrix_muc_gland_total_asthma.xlsx\")\n</pre> # Import Regis' cluster labeling matrix_epi = pd.read_excel(\"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ST_Regis_analysis/data/Cell_matrices_D2C/matrix_epithelium_total_filter_asthma.xlsx\") matrix_muc = pd.read_excel(\"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ST_Regis_analysis/data/Cell_matrices_D2C/Matrix_muc_gland_total_asthma.xlsx\") In\u00a0[11]: Copied! <pre># Format matrix\nmatrix_epi.index = matrix_epi[\"Cell_ID\"]\nmatrix_epi = matrix_epi.rename(columns={\"Cluster\": \"Regis_cluster\"})\nmatrix_epi[\"Patient\"] = matrix_epi[\"Patient\"].astype(str)\nmatrix_epi[\"ROI\"] = \"Epithelium\"\nmatrix_epi\n</pre> # Format matrix matrix_epi.index = matrix_epi[\"Cell_ID\"] matrix_epi = matrix_epi.rename(columns={\"Cluster\": \"Regis_cluster\"}) matrix_epi[\"Patient\"] = matrix_epi[\"Patient\"].astype(str) matrix_epi[\"ROI\"] = \"Epithelium\" matrix_epi Out[11]: Cell_ID Regis_cluster Pathology Patient Transcripts ACE ACE2 ACKR1 ADAM17 ADAM28 ... UPK3B VEGFA VEGFC VSIG4 VWF WFS1 WNT2 WT1 XCR1 ROI Cell_ID aadeodah-1 aadeodah-1 Basal cells 1 Healthy 110032 87 0 0 0 1 0 ... 0 0 0 0 0 0 0 0 0 Epithelium aadnbbbk-1 aadnbbbk-1 Basal cells 1 Healthy 110032 49 0 0 0 0 1 ... 0 0 0 0 0 0 0 0 0 Epithelium aadonleh-1 aadonleh-1 Basal cells 1 Healthy 110032 48 0 0 0 0 2 ... 0 0 0 0 0 0 0 0 0 Epithelium aadpbghk-1 aadpbghk-1 Basal cells 1 Healthy 110032 19 0 0 0 0 0 ... 0 0 0 0 0 1 0 0 0 Epithelium aafjimli-1 aafjimli-1 Basal cells 1 Healthy 110032 113 0 0 0 0 1 ... 1 0 0 0 0 0 0 0 0 Epithelium ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... hkcjgbai-1 hkcjgbai-1 SMCs 4 Asthma 110001 28 1 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Epithelium manilhbg-1 manilhbg-1 SMCs 4 Asthma 110007 8 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Epithelium mapjnddn-1 mapjnddn-1 SMCs 4 Asthma 110007 36 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Epithelium mapkfdhd-1 mapkfdhd-1 SMCs 4 Asthma 110007 13 0 0 0 0 0 ... 0 0 0 1 0 0 0 0 0 Epithelium mbahoini-1 mbahoini-1 SMCs 4 Asthma 110007 32 0 1 0 0 1 ... 0 0 0 0 0 0 0 0 0 Epithelium <p>23105 rows \u00d7 345 columns</p> In\u00a0[12]: Copied! <pre>matrix_muc.index = matrix_muc[\"Cell_ID\"]\nmatrix_muc = matrix_muc.rename(columns={\"Cluster\": \"Regis_cluster\"})\nmatrix_muc[\"Patient\"] = matrix_muc[\"Patient\"].astype(str)\nmatrix_muc[\"ROI\"] = \"Mucosal_gland\"\nmatrix_muc\n</pre> matrix_muc.index = matrix_muc[\"Cell_ID\"] matrix_muc = matrix_muc.rename(columns={\"Cluster\": \"Regis_cluster\"}) matrix_muc[\"Patient\"] = matrix_muc[\"Patient\"].astype(str) matrix_muc[\"ROI\"] = \"Mucosal_gland\" matrix_muc Out[12]: Cell_ID Regis_cluster Transcripts Patient Pathology ACE ACE2 ACKR1 ADAM17 ADAM28 ... UPK3B VEGFA VEGFC VSIG4 VWF WFS1 WNT2 WT1 XCR1 ROI Cell_ID fjkkcgcb-1 fjkkcgcb-1 Basal cells 1 21 110032 Healthy 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Mucosal_gland fjkmecdi-1 fjkmecdi-1 Basal cells 1 20 110032 Healthy 0 0 0 0 0 ... 0 0 0 0 0 0 1 0 0 Mucosal_gland fkeggnmf-1 fkeggnmf-1 Basal cells 1 35 110032 Healthy 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Mucosal_gland fkehnhkj-1 fkehnhkj-1 Basal cells 1 72 110032 Healthy 0 0 0 0 1 ... 0 0 0 0 0 0 0 0 0 Mucosal_gland knndgahg-1 knndgahg-1 Basal cells 1 27 110040 Healthy 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Mucosal_gland ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... gfpadpfl-1 gfpadpfl-1 SMCs 4 18 110001 Asthma 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Mucosal_gland gfpajmjo-1 gfpajmjo-1 SMCs 4 26 110001 Asthma 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Mucosal_gland gfpbphdi-1 gfpbphdi-1 SMCs 4 52 110001 Asthma 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Mucosal_gland hngbeaef-1 hngbeaef-1 SMCs 4 7 110001 Asthma 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Mucosal_gland lobdedfn-1 lobdedfn-1 SMCs 4 43 110007 Asthma 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 Mucosal_gland <p>19583 rows \u00d7 345 columns</p> In\u00a0[13]: Copied! <pre># Combine both matrices\nmatrix = pd.concat([matrix_epi, matrix_muc], axis=0) # combine based on columns\nprint(\"Number of cells from each\",matrix[\"ROI\"].value_counts())\n\nmatrix = matrix[[\"Cell_ID\", \"ROI\", \"Regis_cluster\", \"Pathology\", \"Patient\"]]\nmatrix.rename(columns={matrix.columns[0]: 'cell_id'}, inplace=True)\nprint(matrix['cell_id'].duplicated().sum())\nmatrix = matrix.drop_duplicates(subset='cell_id')\n</pre> # Combine both matrices matrix = pd.concat([matrix_epi, matrix_muc], axis=0) # combine based on columns print(\"Number of cells from each\",matrix[\"ROI\"].value_counts())  matrix = matrix[[\"Cell_ID\", \"ROI\", \"Regis_cluster\", \"Pathology\", \"Patient\"]] matrix.rename(columns={matrix.columns[0]: 'cell_id'}, inplace=True) print(matrix['cell_id'].duplicated().sum()) matrix = matrix.drop_duplicates(subset='cell_id') <pre>Number of cells from each ROI\nEpithelium       23105\nMucosal_gland    19583\nName: count, dtype: int64\n6\n</pre> In\u00a0[14]: Copied! <pre>adata.obs = adata.obs.join(matrix.set_index('cell_id'), how='left')\nadata.obs\n</pre> adata.obs = adata.obs.join(matrix.set_index('cell_id'), how='left') adata.obs Out[14]: cell_id x_centroid y_centroid transcript_counts control_probe_counts control_codeword_counts unassigned_codeword_counts deprecated_codeword_counts total_counts cell_area ... pct_counts_in_top_10_genes pct_counts_in_top_20_genes pct_counts_in_top_50_genes n_counts leiden_1.0 new_clusters ROI Regis_cluster Pathology Patient aaadnhbi-1 aaadnhbi-1 1647.581299 5919.916992 14 0 0 0 0 14.0 804.232842 ... 92.857143 100.000000 100.0000 14.0 5 5 Epithelium SMCs 1 Healthy 110028 aaaoajok-1 aaaoajok-1 2413.369385 3389.042480 15 0 0 0 0 15.0 93.789535 ... 66.666667 100.000000 100.0000 15.0 15 15 Epithelium Cluster 3 Healthy 110032 aabgppbe-1 aabgppbe-1 2429.717041 3389.562744 36 0 0 0 0 36.0 263.215791 ... 61.111111 88.888889 100.0000 36.0 7 SMC Epithelium Endothelial cells 2 Healthy 110032 aabhhaho-1 aabhhaho-1 2443.484375 3395.104492 22 0 0 0 0 22.0 160.304693 ... 63.636364 100.000000 100.0000 22.0 7 SMC Epithelium Endothelial cells 2 Healthy 110032 aacnpnlp-1 aacnpnlp-1 2494.154541 3380.241211 11 0 0 0 0 11.0 148.699537 ... 100.000000 100.000000 100.0000 11.0 3 Fibroblasts Epithelium Fibroblasts Healthy 110032 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ojcbmknb-1 ojcbmknb-1 8341.762695 20044.416016 37 0 0 0 0 37.0 110.497348 ... 37.837838 64.864865 100.0000 37.0 10 10 NaN NaN NaN NaN ojcdjpnk-1 ojcdjpnk-1 8348.761719 20057.220703 39 0 0 0 0 39.0 261.815947 ... 33.333333 58.974359 100.0000 39.0 12 NK cells NaN NaN NaN NaN ojcdodjh-1 ojcdodjh-1 8351.383789 20081.843750 18 0 0 0 0 18.0 199.680945 ... 66.666667 100.000000 100.0000 18.0 6 6 NaN NaN NaN NaN ojcgaphj-1 ojcgaphj-1 8350.867188 20041.492188 21 0 0 0 0 21.0 63.083284 ... 47.619048 95.238095 100.0000 21.0 13 Macrophages NaN NaN NaN NaN ojcgnoil-1 ojcgnoil-1 8354.194336 20048.212891 64 0 0 0 0 64.0 82.048909 ... 26.562500 42.187500 89.0625 64.0 0 Pericyte/SMC NaN NaN NaN NaN <p>53468 rows \u00d7 24 columns</p> In\u00a0[15]: Copied! <pre># Format Regis_cluster column to be a string\nadata.obs[\"Regis_cluster\"] = adata.obs[\"Regis_cluster\"].astype('str') # convert to string\n\nadata.obs.dtypes\nadata.obs[\"Regis_cluster\"].value_counts()\n</pre> # Format Regis_cluster column to be a string adata.obs[\"Regis_cluster\"] = adata.obs[\"Regis_cluster\"].astype('str') # convert to string  adata.obs.dtypes adata.obs[\"Regis_cluster\"].value_counts() Out[15]: <pre>Regis_cluster\nnan                             15407\nCluster 1                        7021\nCluster 2                        6672\nCluster 3                        3402\nEndothelial cells 1              2843\nFibroblasts                      2581\nBasal cells 1                    2470\nBasal cells 2                    2148\nMast cells                       1923\nSMCs 1                           1532\nCiliated cells 2                 1302\nGoblet cells (Epithelium)        1142\nSerous cells 1                   1125\nCiliated cells 1                 1068\nGoblet cells (Mucous glands)      761\nSMCs 2 Des+                       527\nSerous cells 2                    490\nEndothelial cells 2               424\nCluster 12                        320\nSMCs 4                            294\nSMCs 3 (Mucous glands)             16\nName: count, dtype: int64</pre> In\u00a0[16]: Copied! <pre># Import Xenium data using muspan\nlogging.info(\"Loading Xenium data for MuSpAn...\")\n\narea_path = Path(input_path) / \"data/regis_d1.csv\"\ntranscripts_of_interest = [\"EPCAM\", \"CD3D\", \"CD68\", \"VWF\", \"PTPRC\", \"ACTA2\"]\n\npc = ms.io.xenium_to_domain(\n    path_to_xenium_data=\"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ST_Xenium_Asthma/data/catalyst_release_RJ_IMPERIAL_Dec05/0013717_asthma_healthy\",\n    cells_from_selection_csv = area_path,\n    domain_name='Regis',\n    load_transcripts=True,\n    selected_transcripts=transcripts_of_interest,\n    load_nuclei=True,\n    load_cells_as_shapes=True,\n    exclude_no_nuclei_cells=True)\n</pre> # Import Xenium data using muspan logging.info(\"Loading Xenium data for MuSpAn...\")  area_path = Path(input_path) / \"data/regis_d1.csv\" transcripts_of_interest = [\"EPCAM\", \"CD3D\", \"CD68\", \"VWF\", \"PTPRC\", \"ACTA2\"]  pc = ms.io.xenium_to_domain(     path_to_xenium_data=\"/Users/sarapatti/Desktop/PhD_projects/Llyod_lab/ST_Xenium_Asthma/data/catalyst_release_RJ_IMPERIAL_Dec05/0013717_asthma_healthy\",     cells_from_selection_csv = area_path,     domain_name='Regis',     load_transcripts=True,     selected_transcripts=transcripts_of_interest,     load_nuclei=True,     load_cells_as_shapes=True,     exclude_no_nuclei_cells=True) <pre>Domain name: Regis\nNumber of objects: 19486\nCollections: ['Cell boundaries', 'Nucleus boundaries', 'Transcripts']\nLabels: ['Cell ID', 'Transcript Counts', 'Cell Area', 'Cluster ID', 'Nucleus Area', 'Transcript ID'] \nNetworks: [] \nDistance matrices: []\n</pre> In\u00a0[17]: Copied! <pre># ...existing code...\ncell_ids = pc.labels[\"Cell ID\"][\"labels\"]\n\n# Build a list of labels for ALL cell_ids, using \"NA\" if not found in adata.obs\nfiltered_regis_clusters = [\n    str(adata.obs.loc[cid, \"Regis_cluster\"]) if cid in adata.obs.index else \"NA\"\n    for cid in cell_ids\n]\n\n# Now filtered_regis_clusters will have the same length as cell_ids\npc.add_labels(\n    label_name=\"Regis_cluster\",\n    labels=filtered_regis_clusters\n)\n</pre> # ...existing code... cell_ids = pc.labels[\"Cell ID\"][\"labels\"]  # Build a list of labels for ALL cell_ids, using \"NA\" if not found in adata.obs filtered_regis_clusters = [     str(adata.obs.loc[cid, \"Regis_cluster\"]) if cid in adata.obs.index else \"NA\"     for cid in cell_ids ]  # Now filtered_regis_clusters will have the same length as cell_ids pc.add_labels(     label_name=\"Regis_cluster\",     labels=filtered_regis_clusters ) In\u00a0[18]: Copied! <pre>pc.collections['Transcripts']\n</pre> pc.collections['Transcripts'] Out[18]: <pre>{'collection_name': 'Transcripts',\n 'collection_name_integer': 2,\n 'objects': array([14206., 14207., 14208., ..., 19483., 19484., 19485.])}</pre> In\u00a0[19]: Copied! <pre># Queries to isolate the different objects within the MuSpAn domain\n\n# Query to isolate cell boundaries\nqCells = ms.query.query(pc, ('Collection',), 'is', 'Cell boundaries')\n\n# Query to isolate transcripts\nqTrans = ms.query.query(pc, ('Collection',), 'is', 'Transcripts')\n\n# Query to isolate nucleus boundaries\nqNuc = ms.query.query(pc, ('Collection',), 'is', 'Nucleus boundaries')\n</pre> # Queries to isolate the different objects within the MuSpAn domain  # Query to isolate cell boundaries qCells = ms.query.query(pc, ('Collection',), 'is', 'Cell boundaries')  # Query to isolate transcripts qTrans = ms.query.query(pc, ('Collection',), 'is', 'Transcripts')  # Query to isolate nucleus boundaries qNuc = ms.query.query(pc, ('Collection',), 'is', 'Nucleus boundaries') In\u00a0[20]: Copied! <pre>print(pc.labels.keys())  # see all keys in the labels dictionary\n</pre> print(pc.labels.keys())  # see all keys in the labels dictionary <pre>dict_keys(['Cell ID', 'Transcript Counts', 'Cell Area', 'Cluster ID', 'Nucleus Area', 'Transcript ID', 'Regis_cluster'])\n</pre> In\u00a0[21]: Copied! <pre>pc.labels[\"Cluster ID\"]\n</pre> pc.labels[\"Cluster ID\"] Out[21]: <pre>{'labels': array(['Cluster 5', 'Cluster 4', 'Cluster 6', ..., 'Cluster 1',\n        'Cluster 3', 'Cluster 3'], dtype='&lt;U10'),\n 'objects': array([0.000e+00, 1.000e+00, 2.000e+00, ..., 7.100e+03, 7.101e+03,\n        7.102e+03]),\n 'labelType': 'categorical',\n 'categories': array(['Cluster 1', 'Cluster 10', 'Cluster 11', 'Cluster 12',\n        'Cluster 13', 'Cluster 14', 'Cluster 15', 'Cluster 16',\n        'Cluster 17', 'Cluster 18', 'Cluster 2', 'Cluster 3', 'Cluster 4',\n        'Cluster 5', 'Cluster 6', 'Cluster 7', 'Cluster 8', 'Cluster 9',\n        'Unassigned'], dtype='&lt;U10'),\n 'nCategories': 19,\n 'labelToInteger': {'Cluster 1': 0,\n  'Cluster 10': 1,\n  'Cluster 11': 2,\n  'Cluster 12': 3,\n  'Cluster 13': 4,\n  'Cluster 14': 5,\n  'Cluster 15': 6,\n  'Cluster 16': 7,\n  'Cluster 17': 8,\n  'Cluster 18': 9,\n  'Cluster 2': 10,\n  'Cluster 3': 11,\n  'Cluster 4': 12,\n  'Cluster 5': 13,\n  'Cluster 6': 14,\n  'Cluster 7': 15,\n  'Cluster 8': 16,\n  'Cluster 9': 17,\n  'Unassigned': 18},\n 'integerToLabel': {0: 'Cluster 1',\n  1: 'Cluster 10',\n  2: 'Cluster 11',\n  3: 'Cluster 12',\n  4: 'Cluster 13',\n  5: 'Cluster 14',\n  6: 'Cluster 15',\n  7: 'Cluster 16',\n  8: 'Cluster 17',\n  9: 'Cluster 18',\n  10: 'Cluster 2',\n  11: 'Cluster 3',\n  12: 'Cluster 4',\n  13: 'Cluster 5',\n  14: 'Cluster 6',\n  15: 'Cluster 7',\n  16: 'Cluster 8',\n  17: 'Cluster 9',\n  18: 'Unassigned'},\n 'numericalLabels': array([13, 12, 14, ...,  0, 11, 11])}</pre> In\u00a0[22]: Copied! <pre># Create a figure with 2x2 subplots\nfig, ax = plt.subplots(figsize=(20, 15), nrows=2, ncols=2)\n\n# Visualise all objects in the MuSpAn domain\nms.visualise.visualise(pc, ax=ax[0, 0], \n                       marker_size=0.05)\nax[0, 0].set_title('All objects')\n\n# Visualise cells, colored by 'Regis_cluster'\nms.visualise.visualise(pc, \n                       color_by=('label', 'Regis_cluster'), \n                       ax=ax[0, 1], \n                       objects_to_plot=qCells)\nax[0, 1].set_title('Cells')\n\n# Visualise transcripts, colored by 'Transcript'\nms.visualise.visualise(pc, \n                       color_by=('label', 'Transcript ID'), \n                       ax=ax[1, 0], \n                       objects_to_plot=qTrans, \n                       marker_size=5)\nax[1, 0].set_title('Transcripts')\n\n# Visualise nuclei, colored by 'Nucleus Area'\nms.visualise.visualise(pc, color_by=('label', 'Nucleus Area'),\n                       ax=ax[1, 1], \n                       objects_to_plot=qNuc, \n                       #vmin=20, \n                       #vmax=200\n                       )\nax[1, 1].set_title('Nuclei')\n</pre> # Create a figure with 2x2 subplots fig, ax = plt.subplots(figsize=(20, 15), nrows=2, ncols=2)  # Visualise all objects in the MuSpAn domain ms.visualise.visualise(pc, ax=ax[0, 0],                         marker_size=0.05) ax[0, 0].set_title('All objects')  # Visualise cells, colored by 'Regis_cluster' ms.visualise.visualise(pc,                         color_by=('label', 'Regis_cluster'),                         ax=ax[0, 1],                         objects_to_plot=qCells) ax[0, 1].set_title('Cells')  # Visualise transcripts, colored by 'Transcript' ms.visualise.visualise(pc,                         color_by=('label', 'Transcript ID'),                         ax=ax[1, 0],                         objects_to_plot=qTrans,                         marker_size=5) ax[1, 0].set_title('Transcripts')  # Visualise nuclei, colored by 'Nucleus Area' ms.visualise.visualise(pc, color_by=('label', 'Nucleus Area'),                        ax=ax[1, 1],                         objects_to_plot=qNuc,                         #vmin=20,                         #vmax=200                        ) ax[1, 1].set_title('Nuclei') Out[22]: <pre>Text(0.5, 1.0, 'Nuclei')</pre> In\u00a0[23]: Copied! <pre># Convert cell boundaries to cell centres (centroids)\npc.convert_objects(\n    population=('Collection', 'Cell boundaries'),\n    object_type='point',\n    conversion_method='centroids',\n    collection_name='Cell centroids',\n    inherit_collections=False\n)\n\n# Plot the cell centres with color based on 'Cluster ID'\nplt.figure(figsize=(10, 6))\nms.visualise.visualise(\n    pc,\n    objects_to_plot=('collection', 'Cell centroids'),\n    color_by='Regis_cluster',\n    ax=plt.gca(),\n    marker_size=3\n)\n</pre> # Convert cell boundaries to cell centres (centroids) pc.convert_objects(     population=('Collection', 'Cell boundaries'),     object_type='point',     conversion_method='centroids',     collection_name='Cell centroids',     inherit_collections=False )  # Plot the cell centres with color based on 'Cluster ID' plt.figure(figsize=(10, 6)) ms.visualise.visualise(     pc,     objects_to_plot=('collection', 'Cell centroids'),     color_by='Regis_cluster',     ax=plt.gca(),     marker_size=3 ) Out[23]: <pre>(&lt;Figure size 1000x600 with 2 Axes&gt;, &lt;Axes: &gt;)</pre> In\u00a0[24]: Copied! <pre>del_network = ms.networks.generate_network(pc,\n                             network_name='Delaunay CC unfiltered',\n                             network_type='Delaunay',\n                             objects_as_nodes=('collection','Cell centroids')\n                             )\n\n# Generate a Delaunay network on the 'Cell centroids' data\n# The network will be stored in the domain.networks dictionary with the name 'Delaunay CC'\ndel_network = ms.networks.generate_network(pc,\n                             network_name='Delaunay CC filtered',\n                             network_type='Delaunay',\n                             objects_as_nodes=('collection','Cell centroids'),\n                             min_edge_distance=0,\n                             max_edge_distance=45\n                             )\n</pre> del_network = ms.networks.generate_network(pc,                              network_name='Delaunay CC unfiltered',                              network_type='Delaunay',                              objects_as_nodes=('collection','Cell centroids')                              )  # Generate a Delaunay network on the 'Cell centroids' data # The network will be stored in the domain.networks dictionary with the name 'Delaunay CC' del_network = ms.networks.generate_network(pc,                              network_name='Delaunay CC filtered',                              network_type='Delaunay',                              objects_as_nodes=('collection','Cell centroids'),                              min_edge_distance=0,                              max_edge_distance=45                              ) In\u00a0[25]: Copied! <pre>list(del_network.edges(data=True))[0]\n</pre> list(del_network.edges(data=True))[0] Out[25]: <pre>(19486,\n 20738,\n {'Distance': 9.143756588182411, 'Inverse Distance': 0.5516394172576841})</pre> In\u00a0[26]: Copied! <pre>print('Delaunay CC unfiltered:',pc.networks['Delaunay CC unfiltered'])\nprint('Delaunay CC filtered:',pc.networks['Delaunay CC filtered'])\n</pre> print('Delaunay CC unfiltered:',pc.networks['Delaunay CC unfiltered']) print('Delaunay CC filtered:',pc.networks['Delaunay CC filtered']) <pre>Delaunay CC unfiltered: Graph with 7103 nodes and 21274 edges\nDelaunay CC filtered: Graph with 7103 nodes and 20940 edges\n</pre> In\u00a0[27]: Copied! <pre># Create a 1x2 subplot for visualizing the original and filtered Delaunay networks\nfig, ax = plt.subplots(1, 2, figsize=(20, 12))\n\n# Plot the original Delaunay network\nax[0].set_title('Delaunay CC unfiltered')\nms.visualise.visualise_network(\n    pc,\n    network_name='Delaunay CC unfiltered',\n    ax=ax[0],\n    edge_weight_name=None,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), \n                          marker_size=5, \n                          add_cbar=False,\n                          color_by=('constant','#4D7EAB'))\n)\n\n# Plot the filtered Delaunay network\nax[1].set_title('Delaunay CC filtered')\nms.visualise.visualise_network(\n    pc,\n    network_name='Delaunay CC filtered',\n    ax=ax[1],\n    edge_weight_name=None,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),\n                          marker_size=5, \n                          add_cbar=False,\n                          color_by=('constant','#4D7EAB'))\n)\n</pre> # Create a 1x2 subplot for visualizing the original and filtered Delaunay networks fig, ax = plt.subplots(1, 2, figsize=(20, 12))  # Plot the original Delaunay network ax[0].set_title('Delaunay CC unfiltered') ms.visualise.visualise_network(     pc,     network_name='Delaunay CC unfiltered',     ax=ax[0],     edge_weight_name=None,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),                            marker_size=5,                            add_cbar=False,                           color_by=('constant','#4D7EAB')) )  # Plot the filtered Delaunay network ax[1].set_title('Delaunay CC filtered') ms.visualise.visualise_network(     pc,     network_name='Delaunay CC filtered',     ax=ax[1],     edge_weight_name=None,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),                           marker_size=5,                            add_cbar=False,                           color_by=('constant','#4D7EAB')) ) Out[27]: <pre>(&lt;Figure size 2000x1200 with 2 Axes&gt;,\n &lt;Axes: title={'center': 'Delaunay CC filtered'}&gt;)</pre> In\u00a0[28]: Copied! <pre># Generate proximity networks with different maximum edge distances\n\ndistance_list = [10, 20, 50]\nfor distance in distance_list:\n    ms.networks.generate_network(\n        pc,\n        network_name=f\"prox network centroids {distance}\",\n        network_type='Proximity',\n        objects_as_nodes=('collection', 'Cell centroids'),\n        max_edge_distance=distance,\n        min_edge_distance=0\n    )\n</pre> # Generate proximity networks with different maximum edge distances  distance_list = [10, 20, 50] for distance in distance_list:     ms.networks.generate_network(         pc,         network_name=f\"prox network centroids {distance}\",         network_type='Proximity',         objects_as_nodes=('collection', 'Cell centroids'),         max_edge_distance=distance,         min_edge_distance=0     ) In\u00a0[29]: Copied! <pre># Create a figure with 3 subplots arranged in a single row\nfig, ax = plt.subplots(1, 3, figsize=(20, 6))\n\n# Plot the proximity network with 10\u03bcm max distance\nax[0].set_title(f\"Proximity network: {distance_list[0]} max distance\")\nms.visualise.visualise_network(\n    pc,\n    network_name=f\"prox network centroids {distance_list[0]}\",\n    ax=ax[0],\n    edge_cmap=color_map,\n    edge_vmin=0,\n    edge_vmax=distance_list[0],\n    add_cbar=False,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),\n                        marker_size=0.5,\n                        color_by=('constant','black')\n                        )\n)\n\n# Plot the proximity network with 10\u03bcm max distance\nax[1].set_title(f\"Proximity network: {distance_list[1]} max distance\")\nms.visualise.visualise_network(\n    pc,\n    network_name=f\"prox network centroids {distance_list[1]}\",\n    ax=ax[1],\n    edge_cmap=color_map,\n    edge_vmin=0,\n    edge_vmax=distance_list[1],\n    add_cbar=False,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),\n                        marker_size=0.5,\n                        color_by=('constant','black')\n                        )\n)\n\n# Plot the proximity network with 10\u03bcm max distance\nax[2].set_title(f\"Proximity network: {distance_list[2]} max distance\")\nms.visualise.visualise_network(\n    pc,\n    network_name=f\"prox network centroids {distance_list[2]}\",\n    ax=ax[2],\n    edge_cmap=color_map,\n    edge_vmin=0,\n    edge_vmax=distance_list[2],\n    add_cbar=True,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), \n                        marker_size=0.5,\n                        color_by=('constant','black')\n                        )\n)\n</pre> # Create a figure with 3 subplots arranged in a single row fig, ax = plt.subplots(1, 3, figsize=(20, 6))  # Plot the proximity network with 10\u03bcm max distance ax[0].set_title(f\"Proximity network: {distance_list[0]} max distance\") ms.visualise.visualise_network(     pc,     network_name=f\"prox network centroids {distance_list[0]}\",     ax=ax[0],     edge_cmap=color_map,     edge_vmin=0,     edge_vmax=distance_list[0],     add_cbar=False,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),                         marker_size=0.5,                         color_by=('constant','black')                         ) )  # Plot the proximity network with 10\u03bcm max distance ax[1].set_title(f\"Proximity network: {distance_list[1]} max distance\") ms.visualise.visualise_network(     pc,     network_name=f\"prox network centroids {distance_list[1]}\",     ax=ax[1],     edge_cmap=color_map,     edge_vmin=0,     edge_vmax=distance_list[1],     add_cbar=False,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),                         marker_size=0.5,                         color_by=('constant','black')                         ) )  # Plot the proximity network with 10\u03bcm max distance ax[2].set_title(f\"Proximity network: {distance_list[2]} max distance\") ms.visualise.visualise_network(     pc,     network_name=f\"prox network centroids {distance_list[2]}\",     ax=ax[2],     edge_cmap=color_map,     edge_vmin=0,     edge_vmax=distance_list[2],     add_cbar=True,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),                          marker_size=0.5,                         color_by=('constant','black')                         ) ) Out[29]: <pre>(&lt;Figure size 2000x600 with 4 Axes&gt;,\n &lt;Axes: title={'center': 'Proximity network: 50 max distance'}&gt;)</pre> In\u00a0[30]: Copied! <pre># Generate a proximity network from shape-like objects (Cell boundaries)\n# with a maximum edge distance of 1\u03bcm\n\nms.networks.generate_network(\n    pc,\n    network_name='Contact network',\n    network_type='Proximity',\n    objects_as_nodes=('collection', 'Cell boundaries'),\n    max_edge_distance=1,\n    min_edge_distance=0\n)\n</pre> # Generate a proximity network from shape-like objects (Cell boundaries) # with a maximum edge distance of 1\u03bcm  ms.networks.generate_network(     pc,     network_name='Contact network',     network_type='Proximity',     objects_as_nodes=('collection', 'Cell boundaries'),     max_edge_distance=1,     min_edge_distance=0 ) <pre>Warning: Performing a proximity network on a large number (&gt;5000) of shapes may be computationally expensive. Consider using network_type=\"Delaunay\" to appromxiate proxmity interactions using cell centroids.\n</pre> <pre>\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In [30], line 4\n      1 # Generate a proximity network from shape-like objects (Cell boundaries)\n      2 # with a maximum edge distance of 1\u03bcm\n----&gt; 4 ms.networks.generate_network(\n      5     pc,\n      6     network_name='Contact network',\n      7     network_type='Proximity',\n      8     objects_as_nodes=('collection', 'Cell boundaries'),\n      9     max_edge_distance=1,\n     10     min_edge_distance=0\n     11 )\n\nFile /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/muspan/networks/generate_network.py:300, in generate_network(domain, network_name, objects_as_nodes, include_boundaries, exclude_boundaries, boundary_exclude_distance, network_type, distance_weighted, inverse_distance_function, min_edge_distance, max_edge_distance, number_of_nearest_neighbours, store_network)\n    297 extra_valid_query_indices = valid_query_indices[extra_validation_indices]\n    298 if len(extra_valid_query_indices) &gt; 0:\n    299     #this is now the bottleneck for any shape or line objects \n--&gt; 300     object_distance = object_to_object_distance_matrix(domain, [object_id], object_indices[extra_valid_query_indices], bypass_checks=True)[0, :]\n    302     final_validation_indices = (object_distance &gt;= min_edge_distance) &amp; (object_distance &lt;= max_edge_distance)\n    303     final_valid_query_indices = extra_valid_query_indices[final_validation_indices]\n\nFile /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/muspan/helpers/object_to_object_distance_matrix.py:177, in object_to_object_distance_matrix(domain, population_A, population_B, overwrite_cache, bypass_checks, distance_metric)\n    175                             break\n    176                         poly_B = verts_to_poly(b_coords[count_b])\n--&gt; 177                         d = distance_polygon_to_polygon(poly_A, poly_B)[0]\n    178                         distance_matrix[ai,bi] = d\n    179                         #TODO implement internal holes for shape to shape distances\n    180                         \n    181 # Update cache\n\nFile /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/muspan/shape_operations/helpers/distance_polygon_to_polygon.py:51, in distance_polygon_to_polygon(polygon_edges_1, polygon_edges_2)\n     49     mindist = d1\n     50 # vertices of poly 2 to edges of poly 1\n---&gt; 51 d2, (point, closepoint) = distance_point_to_line_segment(e2[0],e1[0],e1[1])\n     52 if d2 &lt; mindist:\n     53     (closepoint1, closepoint2) = (point, closepoint)\n\nFile /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/muspan/shape_operations/helpers/distance_point_to_line_segment.py:37, in distance_point_to_line_segment(point, v1, v2)\n     35 if seglengthsquared == 0:\n     36     assert(1==2)\n---&gt; 37 r = np.dot(v2-v1,point-v1)/seglengthsquared\n     38 if r &lt;= 0:\n     39     d = np.sqrt((point-v1).dot(point-v1))\n\nFile /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/numpy/core/multiarray.py:741, in dot(a, b, out)\n    671     \"\"\"\n    672     result_type(*arrays_and_dtypes)\n    673 \n   (...)\n    736 \n    737     \"\"\"\n    738     return arrays_and_dtypes\n--&gt; 741 @array_function_from_c_func_and_dispatcher(_multiarray_umath.dot)\n    742 def dot(a, b, out=None):\n    743     \"\"\"\n    744     dot(a, b, out=None)\n    745 \n   (...)\n    829 \n    830     \"\"\"\n    831     return (a, b, out)\n\nKeyboardInterrupt: </pre> In\u00a0[\u00a0]: Copied! <pre># Create a figure with a single subplot\nfig, ax = plt.subplots(1, 1, figsize=(6, 6))\n\n# Plot the cell boundaries underneath the network\nms.visualise.visualise(\n    pc,\n    ax=ax,\n    objects_to_plot=('collection', 'Cell boundaries'),\n    marker_size=10,\n    add_cbar=False,\n    shape_kwargs={'color': '#4D7EAB', \n                  'alpha': 0.4, \n                  'edgecolor': 'black'},\n)\n\n# Plot the contact network on top of the cell boundaries\nms.visualise.visualise_network(\n    pc,\n    network_name='Contact network',\n    ax=ax,\n    edge_weight_name=None,\n    visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'), \n                        marker_size=0.5,\n                        color_by=('constant','black')\n                        )\n)\n</pre> # Create a figure with a single subplot fig, ax = plt.subplots(1, 1, figsize=(6, 6))  # Plot the cell boundaries underneath the network ms.visualise.visualise(     pc,     ax=ax,     objects_to_plot=('collection', 'Cell boundaries'),     marker_size=10,     add_cbar=False,     shape_kwargs={'color': '#4D7EAB',                    'alpha': 0.4,                    'edgecolor': 'black'}, )  # Plot the contact network on top of the cell boundaries ms.visualise.visualise_network(     pc,     network_name='Contact network',     ax=ax,     edge_weight_name=None,     visualise_kwargs=dict(objects_to_plot=('collection', 'Cell centroids'),                          marker_size=0.5,                         color_by=('constant','black')                         ) ) <p>Network_method argument and defining the number of neighbours we\u2019d like to connect for every node using the number_of_nearest_neighbours parameter</p> In\u00a0[\u00a0]: Copied! <pre># Generate a K-Nearest Neighbours (KNN) network on the 'Cell centroids' data with k neighbors\nk_list = [2, 5, 10, 15]\n\nfor k in k_list:\n    ms.networks.generate_network(\n        pc,\n        network_name=f\"{k}-NN network\",\n        network_type='KNN',\n        objects_as_nodes=('collection', 'Cell centroids'),\n        number_of_nearest_neighbours=k\n    )\n</pre> # Generate a K-Nearest Neighbours (KNN) network on the 'Cell centroids' data with k neighbors k_list = [2, 5, 10, 15]  for k in k_list:     ms.networks.generate_network(         pc,         network_name=f\"{k}-NN network\",         network_type='KNN',         objects_as_nodes=('collection', 'Cell centroids'),         number_of_nearest_neighbours=k     ) In\u00a0[\u00a0]: Copied! <pre>fig, axes = plt.subplots(1, len(k_list), figsize=(6 * len(k_list), 6))\n\nif len(k_list) == 1:\n    axes = [axes]  # Ensure axes is iterable\n\nfor i, k in enumerate(k_list):\n    axes[i].set_title(f\"{k}-NN network\")\n    ms.visualise.visualise_network(\n        pc,\n        network_name=f\"{k}-NN network\",\n        ax=axes[i],\n        edge_weight_name='Distance',\n        edge_cmap=color_map,\n        visualise_kwargs=dict(\n            objects_to_plot=('collection', 'Cell centroids'),\n            marker_size=1,\n            color_by=('constant', 'black')\n        )\n    )\n\nplt.tight_layout()\nplt.show()\n</pre> fig, axes = plt.subplots(1, len(k_list), figsize=(6 * len(k_list), 6))  if len(k_list) == 1:     axes = [axes]  # Ensure axes is iterable  for i, k in enumerate(k_list):     axes[i].set_title(f\"{k}-NN network\")     ms.visualise.visualise_network(         pc,         network_name=f\"{k}-NN network\",         ax=axes[i],         edge_weight_name='Distance',         edge_cmap=color_map,         visualise_kwargs=dict(             objects_to_plot=('collection', 'Cell centroids'),             marker_size=1,             color_by=('constant', 'black')         )     )  plt.tight_layout() plt.show() <p>We can see that each object should be connected to only 10 other objects in our domain</p> In\u00a0[\u00a0]: Copied! <pre># Initialize an empty list to store the number of neighbours for each node\nnumber_of_neighbours_check = []\n\n# Iterate through each node in the 'f\"{k}-NN network\"k'\nfor node in pc.networks[f\"{k}-NN network\"].nodes():\n    # Append the number of neighbours for the current node to the list\n    number_of_neighbours_check.append(len(list(pc.networks[f\"{k}-NN network\"].neighbors(node))))\n\n# Print the number of adjacent nodes for the first 100 nodes\nprint('Number of adjacent nodes for the first 100 nodes:', number_of_neighbours_check[:100])\n</pre> # Initialize an empty list to store the number of neighbours for each node number_of_neighbours_check = []  # Iterate through each node in the 'f\"{k}-NN network\"k' for node in pc.networks[f\"{k}-NN network\"].nodes():     # Append the number of neighbours for the current node to the list     number_of_neighbours_check.append(len(list(pc.networks[f\"{k}-NN network\"].neighbors(node))))  # Print the number of adjacent nodes for the first 100 nodes print('Number of adjacent nodes for the first 100 nodes:', number_of_neighbours_check[:100]) In\u00a0[\u00a0]: Copied! <pre># # Query the domain for points of Celltype D\n# pop = ms.query.query(pc, ('label', 'Regis_cluster'), 'is', 'Mast cells')\n\n# # Calculate the cross-PCF for points of Celltype D with themselves\n# # max_R: maximum radius to consider\n# # annulus_step: step size for the annulus\n# # annulus_width: width of the annulus\n# # visualise_output: whether to visualise the output\n# r, PCF = ms.spatial_statistics.cross_pair_correlation_function(\n#     domain=pc,\n#     population_A=pop,\n#     population_B=pop,\n#     max_R=200,\n#     annulus_step=5,\n#     annulus_width=25,\n#     visualise_output=True\n# )\n</pre> # # Query the domain for points of Celltype D # pop = ms.query.query(pc, ('label', 'Regis_cluster'), 'is', 'Mast cells')  # # Calculate the cross-PCF for points of Celltype D with themselves # # max_R: maximum radius to consider # # annulus_step: step size for the annulus # # annulus_width: width of the annulus # # visualise_output: whether to visualise the output # r, PCF = ms.spatial_statistics.cross_pair_correlation_function( #     domain=pc, #     population_A=pop, #     population_B=pop, #     max_R=200, #     annulus_step=5, #     annulus_width=25, #     visualise_output=True # ) In\u00a0[32]: Copied! <pre># Clusters\ncluster_labels = 'Regis_cluster'\ncelltypes = pc.labels[cluster_labels]['labels'].tolist()\ncelltypes = np.unique(celltypes)\n\n# Define the cell types to be analyzed\ncelltypes = pc.labels[cluster_labels]['labels'].tolist()\ncelltypes = np.unique(celltypes)\n</pre> # Clusters cluster_labels = 'Regis_cluster' celltypes = pc.labels[cluster_labels]['labels'].tolist() celltypes = np.unique(celltypes)  # Define the cell types to be analyzed celltypes = pc.labels[cluster_labels]['labels'].tolist() celltypes = np.unique(celltypes) In\u00a0[\u00a0]: Copied! <pre># # Create a n x n subplot for visualizing the cross-PCF for each combination of cell types\n# fig, axes = plt.subplots(len(celltypes), len(celltypes), figsize=(40, 40))\n\n# # Loop through each combination of cell types\n# for i in range(len(celltypes)):\n#     for j in range(len(celltypes)):\n#         pop_A = ms.query.query(pc, ('label', cluster_labels), 'is', celltypes[i])\n#         pop_B = ms.query.query(pc, ('label', cluster_labels), 'is', celltypes[j])\n#         r, PCF = ms.spatial_statistics.cross_pair_correlation_function(\n#             pc,\n#             pop_A,\n#             pop_B,\n#             max_R=200,\n#             annulus_step=5,\n#             annulus_width=25\n#         )\n\n#         # Select the current subplot\n#         ax = axes[i, j]\n\n#         # Plot the cross-PCF\n#         ax.plot(r, PCF)\n\n#         # Add a horizontal line at y=1 to indicate the CSR baseline\n#         ax.axhline(1, color='k', linestyle=':')\n\n#         # Set the y-axis limit\n#         ax.set_ylim([0, 7])\n\n#         # Label the y-axis with the cross-PCF notation\n#         ax.set_ylabel(f'$g_{{{celltypes[i]}{celltypes[j]}}}(r)$')\n\n#         # Label the x-axis with the distance r\n#         ax.set_xlabel('$r$')\n\n# # Adjust the layout to prevent overlap\n# plt.tight_layout()\n</pre>  # # Create a n x n subplot for visualizing the cross-PCF for each combination of cell types # fig, axes = plt.subplots(len(celltypes), len(celltypes), figsize=(40, 40))  # # Loop through each combination of cell types # for i in range(len(celltypes)): #     for j in range(len(celltypes)): #         pop_A = ms.query.query(pc, ('label', cluster_labels), 'is', celltypes[i]) #         pop_B = ms.query.query(pc, ('label', cluster_labels), 'is', celltypes[j]) #         r, PCF = ms.spatial_statistics.cross_pair_correlation_function( #             pc, #             pop_A, #             pop_B, #             max_R=200, #             annulus_step=5, #             annulus_width=25 #         )  #         # Select the current subplot #         ax = axes[i, j]  #         # Plot the cross-PCF #         ax.plot(r, PCF)  #         # Add a horizontal line at y=1 to indicate the CSR baseline #         ax.axhline(1, color='k', linestyle=':')  #         # Set the y-axis limit #         ax.set_ylim([0, 7])  #         # Label the y-axis with the cross-PCF notation #         ax.set_ylabel(f'$g_{{{celltypes[i]}{celltypes[j]}}}(r)$')  #         # Label the x-axis with the distance r #         ax.set_xlabel('$r$')  # # Adjust the layout to prevent overlap # plt.tight_layout() In\u00a0[\u00a0]: Copied! <pre># Query points with labels \"Basal cells 1\" or \"Mast cells\"\nquery_ab = ms.query.query(pc, ('label', cluster_labels), 'in', [\"Basal cells 1\", \"Mast cells\"])\n\nms.visualise.visualise(\n    pc, \n    color_by=('label', cluster_labels),\n    objects_to_plot=query_ab\n)\n</pre> # Query points with labels \"Basal cells 1\" or \"Mast cells\" query_ab = ms.query.query(pc, ('label', cluster_labels), 'in', [\"Basal cells 1\", \"Mast cells\"])  ms.visualise.visualise(     pc,      color_by=('label', cluster_labels),     objects_to_plot=query_ab ) In\u00a0[\u00a0]: Copied! <pre># Create a n x n subplot for visualizing the cross-PCF for each combination of cell types\n\npop_A = ms.query.query(pc, ('label', cluster_labels), 'is', \"Basal cells 1\")\npop_B = ms.query.query(pc, ('label', cluster_labels), 'is', \"Mast cells\")\n\n# Calculate the cross-PCF for points of Celltype D with themselves\n# max_R: maximum radius to consider\n# annulus_step: step size for the annulus\n# annulus_width: width of the annulus\n# visualise_output: whether to visualise the output\nr, PCF = ms.spatial_statistics.cross_pair_correlation_function(\n    domain=pc,\n    population_A=pop_A,\n    population_B=pop_B,\n    max_R=200,\n    annulus_step=5,\n    annulus_width=25,\n    visualise_output=True\n)\n</pre>  # Create a n x n subplot for visualizing the cross-PCF for each combination of cell types  pop_A = ms.query.query(pc, ('label', cluster_labels), 'is', \"Basal cells 1\") pop_B = ms.query.query(pc, ('label', cluster_labels), 'is', \"Mast cells\")  # Calculate the cross-PCF for points of Celltype D with themselves # max_R: maximum radius to consider # annulus_step: step size for the annulus # annulus_width: width of the annulus # visualise_output: whether to visualise the output r, PCF = ms.spatial_statistics.cross_pair_correlation_function(     domain=pc,     population_A=pop_A,     population_B=pop_B,     max_R=200,     annulus_step=5,     annulus_width=25,     visualise_output=True ) In\u00a0[\u00a0]: Copied! <pre># # Visualize the domain with points colored by their mark\n# ms.visualise.visualise(pc, \n#                        color_by='EPCAM', \n#                        figure_kwargs={'figsize': (8, 6)})\n</pre> # # Visualize the domain with points colored by their mark # ms.visualise.visualise(pc,  #                        color_by='EPCAM',  #                        figure_kwargs={'figsize': (8, 6)}) In\u00a0[\u00a0]: Copied! <pre># # Query population A from the domain\n# popA = ms.query.query(pc, ('label', cluster_labels), 'is', 'Cluster 8')\n\n# # Query population B from the domain\n# popB = ms.query.query(pc, ('label', cluster_labels), 'is', 'Cluster 2')\n\n# # Calculate the weighted pair correlation function (wPCF)\n# # Parameters:\n# # - domain: the domain containing the points\n# # - popA: the first population of points (A)\n# # - popB: the second population of points (B)\n# # - mark_pop_B: the label/mark associated with population B\n# # - max_R: the maximum radius to consider for the wPCF\n# # - annulus_step: the step size for the annulus radii\n# # - annulus_width: the width of each annulus\n# radii, wPCF = ms.spatial_statistics.weighted_pair_correlation_function(\n#     pc, \n#     popA, \n#     popB, \n#     mark_pop_B='EPCAM', \n#     max_R=1, \n#     annulus_step=0.1, \n#     annulus_width=0.15\n# )\n</pre> # # Query population A from the domain # popA = ms.query.query(pc, ('label', cluster_labels), 'is', 'Cluster 8')  # # Query population B from the domain # popB = ms.query.query(pc, ('label', cluster_labels), 'is', 'Cluster 2')  # # Calculate the weighted pair correlation function (wPCF) # # Parameters: # # - domain: the domain containing the points # # - popA: the first population of points (A) # # - popB: the second population of points (B) # # - mark_pop_B: the label/mark associated with population B # # - max_R: the maximum radius to consider for the wPCF # # - annulus_step: the step size for the annulus radii # # - annulus_width: the width of each annulus # radii, wPCF = ms.spatial_statistics.weighted_pair_correlation_function( #     pc,  #     popA,  #     popB,  #     mark_pop_B='EPCAM',  #     max_R=1,  #     annulus_step=0.1,  #     annulus_width=0.15 # )  <p>Compute Moran\u2019s I and Getis-Ord on grid-like data.</p> In\u00a0[\u00a0]: Copied! <pre>cd3 = ms.query.query(pc, ('label', \"Transcript ID\"), 'is', \"CD3D\")\n</pre> cd3 = ms.query.query(pc, ('label', \"Transcript ID\"), 'is', \"CD3D\") <p>This dataset is composed of point-like data however hotspot analysis is typically conducted on lattice- or grid-like data (think states on a map of the US). More recently, hotspot analysis has emerged as a useful tool in cancer research for analysising regional transcriptomics datasets such as those produced using Visium HD. In fact, spatial autocorrelations can be computed on any type of spatial data - not just grid-like data! We\u2019ll see this later in this tutorial.</p> In\u00a0[\u00a0]: Copied! <pre># Generate a hexagonal grid over the example domain\n# - side_length: length of the side of each hexagon\n# - regions_collection_name: name of the collection of hexagonal regions\n\nlength_list = [50,100]  # Set the side length of the hexagons\n\nfor length in length_list:\n    ms.region_based.generate_hexgrid(pc, \n                                    side_length=length, \n                                    regions_collection_name=f\"Hexgrids {length}\")\n</pre> # Generate a hexagonal grid over the example domain # - side_length: length of the side of each hexagon # - regions_collection_name: name of the collection of hexagonal regions  length_list = [50,100]  # Set the side length of the hexagons  for length in length_list:     ms.region_based.generate_hexgrid(pc,                                      side_length=length,                                      regions_collection_name=f\"Hexgrids {length}\") In\u00a0[\u00a0]: Copied! <pre>print(pc)\n</pre> print(pc) In\u00a0[\u00a0]: Copied! <pre>fig,ax=plt.subplots(figsize=(13,6))\nms.visualise.visualise(pc, \n                       #color_by='region counts: T Helper Cell',\n                       objects_to_plot=('collection','Hexgrids 50'),\n                       ax=ax) \nms.visualise.visualise(pc, \n                       color_by='Regis_cluster',\n                       objects_to_plot=('collection','Cell centroids'),\n                       ax=ax,\n                       marker_size=5)  # plot the points\n</pre> fig,ax=plt.subplots(figsize=(13,6)) ms.visualise.visualise(pc,                         #color_by='region counts: T Helper Cell',                        objects_to_plot=('collection','Hexgrids 50'),                        ax=ax)  ms.visualise.visualise(pc,                         color_by='Regis_cluster',                        objects_to_plot=('collection','Cell centroids'),                        ax=ax,                        marker_size=5)  # plot the points <p>Compute Moran\u2019s I and Getis-Ord directly on spatial data (point-like / any MuSpAn object)</p> In\u00a0[33]: Copied! <pre># Perform neighbourhood clustering on the dataset using KNN and minibatchkmeans\n# ? Can I call a network I already created and stored in Networks?\n\nneighbourhood_enrichment_matrix, consistent_global_labels, unique_cluster_labels = ms.networks.cluster_neighbourhoods(\n    pc,  # The domain dataset\n    label_name=cluster_labels,  # The label to use for clustering\n    network_kwargs=dict(network_type='KNN', \n                        max_edge_distance=np.inf, \n                        min_edge_distance=0, \n                        number_of_nearest_neighbours=10),  # The network parameters\n    k_hops=1,  # The number of hops to consider for the neighbourhood\n    neighbourhood_label_name='Neighbourhood ID',  # Name for the neighbourhood label\n    cluster_method='minibatchkmeans',  # Clustering method\n    cluster_parameters={'n_clusters': 6},  # Parameters for the clustering method\n    neighbourhood_enrichment_as='log-fold' # Neighbourhood enrichment as log-fold\n)\n</pre> # Perform neighbourhood clustering on the dataset using KNN and minibatchkmeans # ? Can I call a network I already created and stored in Networks?  neighbourhood_enrichment_matrix, consistent_global_labels, unique_cluster_labels = ms.networks.cluster_neighbourhoods(     pc,  # The domain dataset     label_name=cluster_labels,  # The label to use for clustering     network_kwargs=dict(network_type='KNN',                          max_edge_distance=np.inf,                          min_edge_distance=0,                          number_of_nearest_neighbours=10),  # The network parameters     k_hops=1,  # The number of hops to consider for the neighbourhood     neighbourhood_label_name='Neighbourhood ID',  # Name for the neighbourhood label     cluster_method='minibatchkmeans',  # Clustering method     cluster_parameters={'n_clusters': 6},  # Parameters for the clustering method     neighbourhood_enrichment_as='log-fold' # Neighbourhood enrichment as log-fold ) <pre>Warning: KNN networks are currently only implemented for point objects, object centroids will used for network construction\n</pre> In\u00a0[34]: Copied! <pre># Visualize the dataset with the neighbourhood clustering results\nms.visualise.visualise(pc, \n                       color_by='Neighbourhood ID',\n                       marker_size=0.5,\n                       objects_to_plot=('collection', 'Cell centroids')\n)\n</pre> # Visualize the dataset with the neighbourhood clustering results ms.visualise.visualise(pc,                         color_by='Neighbourhood ID',                        marker_size=0.5,                        objects_to_plot=('collection', 'Cell centroids') ) Out[34]: <pre>(&lt;Figure size 1000x800 with 2 Axes&gt;, &lt;Axes: &gt;)</pre> In\u00a0[35]: Copied! <pre># Create a DataFrame from the neighbourhood enrichment matrix\ndf_ME_id = pd.DataFrame(data=neighbourhood_enrichment_matrix, \n                        index=unique_cluster_labels, \n                        columns=consistent_global_labels)\ndf_ME_id.index.name = 'Neighbourhood ID'\ndf_ME_id.columns.name = 'Celltype ID'\n\n# Check for non-finite values\nnon_finite_mask = ~np.isfinite(df_ME_id.values)\n\nif non_finite_mask.any():\n    print(\"Warning: Non-finite values found. Replacing with 0.\")\n    df_ME_id = df_ME_id.replace([np.inf, -np.inf], np.nan).fillna(0)\n</pre> # Create a DataFrame from the neighbourhood enrichment matrix df_ME_id = pd.DataFrame(data=neighbourhood_enrichment_matrix,                          index=unique_cluster_labels,                          columns=consistent_global_labels) df_ME_id.index.name = 'Neighbourhood ID' df_ME_id.columns.name = 'Celltype ID'  # Check for non-finite values non_finite_mask = ~np.isfinite(df_ME_id.values)  if non_finite_mask.any():     print(\"Warning: Non-finite values found. Replacing with 0.\")     df_ME_id = df_ME_id.replace([np.inf, -np.inf], np.nan).fillna(0)  In\u00a0[37]: Copied! <pre># Visualize the neighbourhood enrichment matrix using a clustermap\nsns.clustermap(\n    df_ME_id,\n    xticklabels=consistent_global_labels,\n    yticklabels=unique_cluster_labels,\n    figsize=(7.5, 3.5),\n    cmap='RdBu_r',\n    dendrogram_ratio=(.05, .3),\n    col_cluster=False,\n    row_cluster=False,\n    square=True,\n    linewidths=0.5,\n    linecolor='black',\n    cbar_kws=dict(use_gridspec=False, \n                  location=\"top\", \n                  label='Neighbourhood enrichment (log-fold)', \n                  ticks=[-2, 0, 2]),\n    cbar_pos=(0.12, 0.75, 0.72, 0.08),\n    vmin=-2,\n    vmax=2,\n    tree_kws={'linewidths': 0, 'color': 'white'}\n)\n</pre> # Visualize the neighbourhood enrichment matrix using a clustermap sns.clustermap(     df_ME_id,     xticklabels=consistent_global_labels,     yticklabels=unique_cluster_labels,     figsize=(7.5, 3.5),     cmap='RdBu_r',     dendrogram_ratio=(.05, .3),     col_cluster=False,     row_cluster=False,     square=True,     linewidths=0.5,     linecolor='black',     cbar_kws=dict(use_gridspec=False,                    location=\"top\",                    label='Neighbourhood enrichment (log-fold)',                    ticks=[-2, 0, 2]),     cbar_pos=(0.12, 0.75, 0.72, 0.08),     vmin=-2,     vmax=2,     tree_kws={'linewidths': 0, 'color': 'white'} ) Out[37]: <pre>&lt;seaborn.matrix.ClusterGrid at 0x188c317e0&gt;</pre> In\u00a0[38]: Copied! <pre>print(pc)\n</pre> print(pc) <pre>Domain name: Regis\nNumber of objects: 26590\nCollections: ['Cell boundaries', 'Nucleus boundaries', 'Transcripts', 'Cell centroids']\nLabels: ['Cell ID', 'Transcript Counts', 'Cell Area', 'Cluster ID', 'Nucleus Area', 'Transcript ID', 'Regis_cluster', 'Neighbourhood ID'] \nNetworks: ['Delaunay CC unfiltered', 'Delaunay CC filtered', 'prox network centroids 10', 'prox network centroids 20', 'prox network centroids 50'] \nDistance matrices: ['object_boundary_distance_cache']\n</pre> In\u00a0[50]: Copied! <pre># Perform community detection using the Louvain method with a resolution \nres = 0.1\n\ncommunities_res_1= ms.networks.community_detection(\n    pc,\n    network_name='Delaunay CC filtered',\n    edge_weight_name=None,\n    community_method='louvain',\n    community_method_parameters=dict(resolution=res),\n    community_label_name= f\"Communities : Res = {res}\",\n)\n</pre> # Perform community detection using the Louvain method with a resolution  res = 0.1  communities_res_1= ms.networks.community_detection(     pc,     network_name='Delaunay CC filtered',     edge_weight_name=None,     community_method='louvain',     community_method_parameters=dict(resolution=res),     community_label_name= f\"Communities : Res = {res}\", ) In\u00a0[57]: Copied! <pre># Visualise the network with communities detected at resolution\nms.visualise.visualise_network(\n    pc,\n    network_name='Delaunay CC filtered',\n    edge_weight_name=None,\n    visualise_kwargs=dict(\n        color_by=f\"Communities : Res = {res}\",\n        marker_size=10,\n        scatter_kwargs=dict(linewidth=0.01, \n                            edgecolor=None\n                            )\n    ),\n    figure_kwargs=dict(figsize=(20, 15))\n)\n</pre> # Visualise the network with communities detected at resolution ms.visualise.visualise_network(     pc,     network_name='Delaunay CC filtered',     edge_weight_name=None,     visualise_kwargs=dict(         color_by=f\"Communities : Res = {res}\",         marker_size=10,         scatter_kwargs=dict(linewidth=0.01,                              edgecolor=None                             )     ),     figure_kwargs=dict(figsize=(20, 15)) ) Out[57]: <pre>(&lt;Figure size 2000x1500 with 2 Axes&gt;, &lt;Axes: &gt;)</pre>"},{"location":"sample_regis/#creating-spatial-networks","title":"Creating spatial networks\u00b6","text":""},{"location":"sample_regis/#delaunay-networks-from-point-like-data","title":"Delaunay networks from point-like data\u00b6","text":"<p>If no boundary information about our spatial objects is given in our dataset (i.e., no segmentation mask), then Deluanay networks on point-like data are a common approximation of the local connectivity of the data. It\u2019s construction is based on area (volume) filling process between all points such that edges are generated to produce triangles that do not contain any other point, therefore an edge between points presents the adjacency of the voronoi cells of the data.</p> <p>Edge weights are values that can be used to describe the connectivity between nodes.</p>"},{"location":"sample_regis/#proximity-based-networks","title":"Proximity based networks\u00b6","text":"<p>Proximity networks are purely distance-based networks. Formally, in a Proximity network, any two nodes are connected if the distance between is within a specified range, which is defined in our case by max_edge_distance and min_edge_distance. These networks are particularly useful in spatial analysis where the physical distance between objects is a key factor. By adjusting the distance thresholds, we can explore how connectivity changes at different spatial scales. This can help in understanding the spatial organization and interactions within the dataset.</p>"},{"location":"sample_regis/#point-like-objects","title":"Point-like objects\u00b6","text":""},{"location":"sample_regis/#shape-like-objects","title":"Shape-like objects\u00b6","text":"<p>Note that the \u2018Contact network\u2019 is defined between the \u2018Cell boundary\u2019 objects but edges will be drawn from their centroids. For purely visualisation purposes, we include the \u2018Cell centroids\u2019 on the plot.</p>"},{"location":"sample_regis/#knn-based-networks","title":"KNN based networks\u00b6","text":""},{"location":"sample_regis/#spatial-statistics","title":"Spatial Statistics\u00b6","text":""},{"location":"sample_regis/#cross-pair-correlation-function-cross-pcf","title":"Cross pair correlation function (cross-PCF)\u00b6","text":"<p>The cross pair correlation function (cross-PCF, also known as the Radial Distribution Function) is a spatial statistic that characterises clustering or exclusion at different length scales. Consider two populations of points, that we\u2019ll call and . Then the cross-PCF, , can be thought of as a ratio describing whether the observed number of pairs of points separated by distance (where one is type and the other type ) is higher or lower than would be expected under a statistical null model. In brief, indicates increased numbers of pairs separated by distance , which indicates clustering. suggests exclusion, or regularity.</p>"},{"location":"sample_regis/#the-weighted-pair-correlation-function-wpcf","title":"The weighted pair correlation function (wPCF)\u00b6","text":"<p>The weighted pair correlation function (wPCF) is a spatial statistic that extends the standard pair correlation function to identify spatial relationships between two point populations, one of which is labelled with a continuous mark. For full details, see https://doi.org/10.1371/journal.pcbi.1010994 or https://doi.org/10.1017/S2633903X24000011.</p> <p>In this tutorial, we briefly reproduce the example from Figure 3 of Quantification of spatial and phenotypic heterogeneity in an agent-based model of tumour-macrophage interactions (PLOS Computational Biology 19(3) https://doi.org/10.1371/journal.pcbi.1010994). We start by placing a line of points from population across the line , and a second population placed randomly across the domain. Population points are assigned a mark</p>"},{"location":"sample_regis/#spatial-autocorrelation-hotspot-analysis","title":"Spatial Autocorrelation (Hotspot Analysis)\u00b6","text":"<p>much they are expressed. Certain genes may be highly active in one region of a tumor while nearly silent in another, and these spatial patterns can provide crucial insights into tumor heterogeneity, the tumor microenvironment, and treatment resistance.</p> <p>To detect and quantify these spatial patterns, we use spatial autocorrelation\u2014a statistical approach that helps us determine whether high or low expression levels of a given gene or marker cluster together within a tissue sample or are randomly distributed. This type of analysis is often called hotspot analysis because it allows us to identify regions of significantly high or low expression\u2014or \u201chot\u201d and \u201ccold\u201d spots\u2014within the spatial landscape of a tissue.</p>"},{"location":"sample_regis/#spatial-network-analysis","title":"Spatial Network Analysis\u00b6","text":""},{"location":"sample_regis/#spatial-network-analysis","title":"Spatial Network Analysis\u00b6","text":"<p>Neighborhood Clustering</p> <ul> <li>Typically groups nodes based on attribute similarity rather than connection patterns. Common in traditional cluster analysis, it aims to minimize intra-cluster variance or maximize similarity metrics (e.g., Euclidean distance in k-means)</li> <li>Similarity-based groups</li> <li>Uses node attributes/features</li> </ul> <p>Community Detection</p> <ul> <li>Focuses on identifying groups of nodes with dense internal connections and sparse external connections within a network. The goal is to reveal inherent structural patterns in relational data (e.g., social networks, collaboration networks).</li> <li>Density-based subgroups</li> <li>Relies on edge connections (network structure)</li> </ul>"},{"location":"sample_regis/#neighbourhood-clustering","title":"Neighbourhood clustering\u00b6","text":""},{"location":"sample_regis/#community-detection","title":"Community detection\u00b6","text":"<p>At its core, community detection identifies highly connected subcomponents within a graph, which can reveal important patterns and relationships. The interpretation of these communities depends on the context of the graph, allowing researchers to gain insights into the underlying dynamics of the system being studied.</p> <p>We perform community detection using the community_detection function in the networks submodule. Specifically, we use the Louvain community detection method, which aims to optimise modularity\u2014ensuring there are more edges within a community than between different communities. This method has several parameters that can influence the behavior of community detection. We recommend reviewing the Louvain algorithm for a deeper understanding: https://doi.org/10.1088/1742-5468/2008/10/P10008.</p> <p>In particular, the resolution parameter plays a key role in controlling the size of the detected communities. A higher resolution value tends to identify smaller, more localised communities, while a lower value results in larger, more global groupings. Adjusting this parameter allows you to tailor the community detection process to your specific needs.</p>"},{"location":"sample_regis/#network-filteration","title":"Network filteration\u00b6","text":"<p>Network filtrations are a powerful tool for analysing spatial networks at multiple resolutions. In a graph filtration, the network is systematically simplified or expanded by progressively adding or removing edges or nodes based on a chosen parameter, such as spatial distance or interaction strength. Properties of the network (i.e., centralities, structural measures) are then computed during this filtration process</p>"},{"location":"sample_regis/#topological-data-analysis","title":"Topological Data Analysis\u00b6","text":""},{"location":"sample_regis/#distribution-analysis","title":"Distribution Analysis\u00b6","text":""},{"location":"sample_regis/#quantifying-morphology","title":"Quantifying Morphology\u00b6","text":""}]}